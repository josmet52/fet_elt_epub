<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>
<html xmlns:epub="http://www.idpf.org/2007/ops" xmlns="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" xml:lang="fr" lang="fr">

<head>
    <title>
        Anim_alternateur_triphase_v1d
    </title>
    <link href="../Styles/pw_table_style_v02_06.css" rel="stylesheet" type="text/css"/>
    <link href="../Styles/anim_styles_v02_03.css" rel="stylesheet" type="text/css"/>
    <script src="../Misc/anim_alternateur_v02_02.js" type="text/javascript">
    </script>
    <link href="../Styles/nav_bar_v02_00.css" rel="stylesheet" type="text/css"/>
    <script src="../Misc/nav_bar_v02_01.js" type="text/javascript">
    </script>
</head>
<body>
    <div class="navbar-ul-bottom w3-bar w3-dark-gray" id="topMoodleNavBarId">
        <a onclick="GoToMoodleHomePage()" href="javascript:void(0)"  class="w3-bar-item w3-button w3-padding-small" style="font-size:12px">
            Moodle
        </a>
        <a href="nav.xhtml" class="w3-bar-item w3-button w3-padding-small" style="font-size:12px">
            Menu
        </a>
        <a href="th_01.xhtml" class="w3-bar-item w3-button w3-padding-small" style="font-size:12px">
            Précédente
        </a>
        <a href="th_02.xhtml" class="w3-bar-item w3-button w3-padding-small" style="font-size:12px">
            Suivante
        </a>
        <br/>
    </div>
    <h2>10.1.1 L'alternateur élémentaire : animation</h2>
    <canvas id="canvas_id" width="1250" height="416" class="canvas">
        Ho la la !!
        <br/>
        Malheureusement votre lecteur ne supporte pas Canvas ... l'animation ne peut pas fonctionner.
        <br/>
    </canvas>
    <br/>
    <form>
        <button class="button_plus_minus-space" type="button" onclick="stepRotorMoinsMoins()">
            --
        </button>
        <button class="button_plus_minus" type="button" onclick="stepRotorMoins()">
            -
        </button>
        <button class="button button-show" type="button" onclick="runMotor()">
            Go/Stop
        </button>
        <button class="button_plus_minus" type="button" onclick="stepRotorPlus()">
            +
        </button>
        <button class="button_plus_minus" type="button" onclick="stepRotorPlusPlus()">
            ++
        </button>
        <div class="textareaphi" id="txt_deg_id">
            φ = 0˚
        </div>
        <div class="textareaph1" id="txt_ph1_id">
            U=0V
        </div>
        <div class="textareaph2" id="txt_ph2_id" style="display: none;">
            ph2
        </div>
        <div class="textareaph3" id="txt_ph3_id" style="display: none;">
            ph3
        </div>
        <label class="btncheck" id="chk_mono_id" style="visibility: hidden;">
            Monophasé
            <input type="checkbox" checked="" id="opt_monophase_yesno" style="cursor: pointer;"/>
        </label>
        <label class="btncheck" id="chk_lines_id" style="visibility: hidden;">
            Pointillés
            <input type="checkbox" checked="" id="opt_lines_yesno" style="cursor: pointer;"/>
        </label>
        <label class="btncheck" id="chk_valeurs_id" style="visibility: hidden;">
            Etiquettes
            <input type="checkbox" checked="" id="opt_valeurs_yesno" style="cursor: pointer;"/>
        </label>
    </form>
    <br/>
        <script>
			
//********************************* choix des fonctionnalités begin **************************************

            var lines_YN = true; // sho/hide dotted lines
            var tension_YN = true; // true : show sinus val
            var monophase_YN = true; // true : monophase
			var valeurs_YN = true;
			var show_btn_check = false;
			
//********************************* choix des fonctionnalités fin **************************************


			// Fonction appellée par le resize
            document.getElementsByTagName("body")[0].onresize = function() {onResizeActionAlternateur()};
			
			// Fonctions appellées par les checkbox
			const chk_lines = document.getElementById("chk_lines_id");
			const chk_mono = document.getElementById("chk_mono_id");
			const chk_val = document.getElementById("chk_valeurs_id");

			if (show_btn_check){
				chk_lines.style.visibility = "visible";
				chk_mono.style.visibility = "visible";
				chk_val.style.visibility = "visible";
			} else {
				chk_lines.style.visibility = "hidden";
				chk_mono.style.visibility = "hidden";
				chk_val.style.visibility = "hidden";
			}
	
			const opt_lines = document.getElementById("opt_lines_yesno");
			const opt_mono = document.getElementById("opt_monophase_yesno");
			const opt_val = document.getElementById("opt_valeurs_yesno");

			opt_lines.onchange = function() {optLinesYesNo(this.checked)};
			opt_lines.checked = lines_YN;
			opt_mono.onchange = function() {optMonophaseYesNo(this.checked)};
			opt_mono.checked = monophase_YN;
			opt_val.onchange = function() {optValeursYesNo(this.checked)};
			opt_val.checked = valeurs_YN;

             // récupérer les informations du canvas
            const canvas_element = document.getElementById("canvas_id");
            const ctx = canvas_element.getContext("2d");

            const txt_deg = document.getElementById("txt_deg_id");
            const txt_ph1 = document.getElementById("txt_ph1_id");
            const txt_ph2 = document.getElementById("txt_ph2_id");
            const txt_ph3 = document.getElementById("txt_ph3_id");

            var w1 = ctx.canvas.width;
            var h1 = ctx.canvas.height;

             // variable de gestion des dimensions 
            var Rr; // Rr = demi hauteur du canvas
            var R; // R = 20% de moins que le demi canvas
            var Rx; // Rx = décalage pour le graphique
            var l_width; // l_width = epaisseur des traits noirs
            var gradLen; // longuer trait fraduation
            var rf; //

             // initialisation dimensions et décalage du graphqie
            var Ymin = 0;
            var Ymax = 0;
            var Xmin = 0;
            var Xmax = 0;
            var Xlen = 0; // longueur de l'axe des x

            var s = 0; // epaisseur du stator
            var r = 0; // rayon moyen du stator
            var p = 0; // angle initial du rotor en degres
            var c = 0; // cote de l'encoche
            var w = 0; // diametre du fil

            const sleep_time = 100; // pause en ms entre deux pas en automatique
            var anim_running = false;
            var stop_asked = false;
            const p_inc = 1; // incrementation pour run auto
            var u_crete = 326; // tension de crête

            const ph1_color = "#ff4500"; // OrangeRed
            const ph2_color = "#87cefa"; // LightSkyBlue
            const ph3_color = "#32cd32"; // LimeGreen
            const label_text_color = "black";

			
			const verif_scope = "le scope est à vérifier";


             // lancer l'animation
             // translater le 0,0 du raphique au centre du stator
             // ************************************************************************
             // programme principal
             // ************************************************************************
            onResizeActionAlternateur(); // calculate all the dimentions
//<![CDATA[
// ************************************************************************
// fonctions dessin de l'animation
// ************************************************************************

function onResizeActionAlternateur () {
    
	
	 // ajuster le canvas a la fenetre
    // var w0 = parseInt(0.95 * window.innerWidth);
    // var h0 = parseInt(0.95*window.innerHeight);
    // var w0 = parseInt(0.95 * document.body.offsetWidth);
    // var h0 = parseInt(0.95 * document.body.offsetHeight);
    // var w0 = parseInt(0.95 * window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);
    // var h0 = parseInt(0.95 * window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight);
    var w0 = parseInt(0.95 * document.body.clientWidth);
    var h0 = parseInt(0.95 * document.body.clientHeight);
	
    // alert("window.innerWidth="+ window.innerWidth+ "\n"+ " document.documentElement.clientWidth="+ document.documentElement.clientWidth+ "\n"+ " document.body.clientWidth="+ document.body.clientWidth+ "\n"+"w0="+ w0/0.95)
	
    var rw = w0 / w1 ;
    var rh = h0 / h1 ;
    var r_scale_factor = 1.03;

	if (rw < rh) {
		rf = rw*r_scale_factor;
		if (rf*h1 > h0){
			rf = rh*r_scale_factor;
		}
	} else {
		rf = rh*r_scale_factor;
		if (rf*w1 > w0){
			rf = rw*r_scale_factor;
		}
	}
	canvas_element.width = w1 * rf; // ajuster la largeur du canvas à la fenetre
	canvas_element.height = h1 * rf; // ajuster la hauteur du canvas à la fenetre

	Rr = canvas_element.height / 2; // si height = 400 alors R = 200
	R = canvas_element.height / 2.22; // si height = 400 alors R = 180
	Rx = canvas_element.height / 1.54; // si height = 400 alors R = 260
	l_width = canvas_element.height / 400;
	gradLen = canvas_element.height / 100;

	 // initialisation dimensions et décalage du graphqie
	Ymin = 0; 
	Ymax = R * 0.9; 
	Xmin = Rx;
	Xmax = 3.7 * R;
	Xlen = Xmax - Xmin; // longueur de l'axe des x
	
	// var Rx = 0
	s = 0.35 * R; // epaisseur du stator
	r = R - s / 2; // rayon moyen du stator
	c = s / 2; // cote de l'encoche
	w = 0.35 * c; // diametre du fil

    RefreshGraphAlternateur();
}

function RefreshGraphAlternateur(){
	if (monophase_YN){
		txt_ph2.style.display = "none";
		txt_ph3.style.display = "none";
		// btn_mono.style.display = "none";
	} else {
		txt_ph2.style.display = "inline-block";
		txt_ph3.style.display = "inline-block";
		// btn_mono.style.display = "inline";
	}
	
	ctx.translate(R + canvas_element.height / 20, R + canvas_element.height / 20);
	drawStator(ctx, r, s, p, c, w); // dessiner le stator
	drawRotor(ctx, R, s, p); // dessiner le rotor
	draw_sinus_alternateur(ctx, Rr, R, p); // dessiner la courbe sinusoidale
	ctx.translate(-R - canvas_element.height / 20, -R - canvas_element.height / 20);
}

function drawStator(ctx, r, s, p, c, w) {
    // dessiner le stator

    // les toles
    var p_rad = p / 180 * Math.PI;
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, 2 * Math.PI);
    ctx.lineWidth = s;
    ctx.strokeStyle = "gray";
    ctx.stroke();
    // la ligne noire extérieure
    ctx.beginPath();
    ctx.arc(0, 0, R, 0, 2 * Math.PI);
    ctx.lineWidth = l_width;
    ctx.strokeStyle = "black";
    ctx.stroke();
    // la ligne noire intérieure
    ctx.beginPath();
    ctx.arc(0, 0, R - s, 0, 2 * Math.PI);
    ctx.lineWidth = l_width;
    ctx.strokeStyle = "black";
    ctx.fillStyle = "green";
    ctx.stroke();

    phase_delta = 15;
    //dessiner les encoches et les fils phase 1
    phase_deg = 0;
    phase_deg_1 = phase_deg + 90;
    drawWire(ctx, r, s, phase_deg_1 - phase_delta, c, w, phase_deg, p);
    drawWire(ctx, r, s, phase_deg_1, c, w, phase_deg, p);
    drawWire(ctx, r, s, phase_deg_1 + phase_delta, c, w, phase_deg, p);
    drawWire(ctx, r, s, phase_deg_1 - phase_delta + 180, c, w, phase_deg, p);
    drawWire(ctx, r, s, phase_deg_1 + 180, c, w, phase_deg, p);
    drawWire(ctx, r, s, phase_deg_1 + phase_delta + 180, c, w, phase_deg, p);

    if (!monophase_YN) {
        //dessiner les encoches et les fils phase 2
        phase_deg = 120;
        phase_deg_1 = phase_deg + 90;
        drawWire(ctx, r, s, phase_deg_1 - phase_delta, c, w, phase_deg, p);
        drawWire(ctx, r, s, phase_deg_1, c, w, phase_deg, p);
        drawWire(ctx, r, s, phase_deg_1 + phase_delta, c, w, phase_deg, p);
        drawWire(ctx, r, s, phase_deg_1 - phase_delta + 180, c, w, phase_deg, p);
        drawWire(ctx, r, s, phase_deg_1 + 180, c, w, phase_deg, p);
        drawWire(ctx, r, s, phase_deg_1 + phase_delta + 180, c, w, phase_deg, p);

        //dessiner les encoches et les fils phase 3
        phase_deg = 240;
        phase_deg_1 = phase_deg + 90;
        drawWire(ctx, r, s, phase_deg_1 - phase_delta, c, w, phase_deg, p);
        drawWire(ctx, r, s, phase_deg_1, c, w, phase_deg, p);
        drawWire(ctx, r, s, phase_deg_1 + phase_delta, c, w, phase_deg, p);
        drawWire(ctx, r, s, phase_deg_1 - phase_delta + 180, c, w, phase_deg, p);
        drawWire(ctx, r, s, phase_deg_1 + 180, c, w, phase_deg, p);
        drawWire(ctx, r, s, phase_deg_1 + phase_delta + 180, c, w, phase_deg, p);
    }
}

function drawWire(ctx, r, s, p, c, w, phase_deg, ph) {
    // dessiner les fils
    var p_rad = p / 180 * Math.PI; // l'angle en radians
    // dessiner l'encoche
    var c1 = R - s - c / 8;
    ctx.rotate(p_rad);
    ctx.translate(c1, -c / 2);
    ctx.beginPath();
    ctx.strokeStyle = "black";
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, c, c);
    ctx.lineWidth = l_width;
    ctx.strokeRect(0, 0, c, c);
    ctx.translate(-c1, c / 2);
    ctx.rotate(-p_rad);

    // dessiner le fil
    var c2 = R - s + w;
    ctx.rotate(p_rad);
    ctx.translate(c2, 0);
    ctx.beginPath();
    ctx.strokeStyle = "black";
    ctx.fillStyle = "#ffe4b5";
    ctx.arc(0, 0, w, 0, 2 * Math.PI);
    ctx.lineWidth = l_width;
    ctx.fill();
    ctx.stroke();
    ctx.translate(-c2, 0);
    ctx.rotate(-p_rad);

    if (phase_deg == 0) {
        ctx.fillStyle = ph1_color; // OrangeRed
        ctx.strokeStyle = ph1_color;
        p_rot = p_rad;
        dp = 0;
    } else if (phase_deg == 120) {
        ctx.fillStyle = ph2_color; // LightSkyBlue
        ctx.strokeStyle = ph2_color;
        p_rot = p_rad;
        dp = 240;
    } else if (phase_deg == 240) {
        ctx.fillStyle = ph3_color; // LimeGreen
        ctx.strokeStyle = ph3_color;
        p_rot = p_rad;
        dp = 120;
    }
    // show the current phase 1
    ctx.rotate(p_rot);
    ctx.translate(c2, 0);
    ctx.beginPath();
    ctx.lineWidth = l_width * 3;

    wf = w * Math.abs(Math.sin((ph + dp) / 180 * Math.PI));

    if (((p + dp) % 360) < 180) {
        if (((ph + dp) % 360) < 180) {
            ctx.moveTo(-wf / 2, -wf / 2);
            ctx.lineTo(wf / 2, wf / 2);
            ctx.moveTo(wf / 2, -wf / 2);
            ctx.lineTo(-wf / 2, wf / 2);
        } else {
            ctx.arc(0, 0, wf * 0.5, 0, 2 * Math.PI);
        }
    } else {
        if (((ph + dp) % 360) >= 180) {
            ctx.moveTo(-wf / 2, -wf / 2);
            ctx.lineTo(wf / 2, wf / 2);
            ctx.moveTo(wf / 2, -wf / 2);
            ctx.lineTo(-wf / 2, wf / 2);
        } else {
            ctx.arc(0, 0, wf * 0.5, 0, 2 * Math.PI);
        }
    }
    ctx.fill();
    ctx.stroke();
    ctx.translate(-c2, 0);
    ctx.rotate(-p_rot); //  - phase_deg/180*Math.PI
}

function drawRotor(ctx, R, s, p) {
    // dessiner le rotor
    ctx.translate(0, 0, 0, 0);
    // effacer le rotor
    ctx.beginPath();
    ctx.fillStyle = "white";
    ctx.lineWidth = l_width;
    ctx.arc(0, 0, (R - s) - 2, 0, 2 * Math.PI);
    ctx.fill();

    //dessiner le rotor
    var stator_angle_rad = p / 180 * Math.PI; // angle en radians
    var stator_len = R - 1.2 * s; // longueur d'un demi rotor
    var stator_width = s; // epaisseur du rotor idem epaisseur du stator
    // taille et police des caracteres N et S
    var letter_height = (l_width * 35).toFixed();
    ctx.font = letter_height + "px Verdana";

    // le pôle sud
    ctx.rotate(stator_angle_rad + Math.PI);
    ctx.translate(0, -stator_width / 2);
    ctx.beginPath();
    ctx.fillStyle = "#00cc00"; // vert clair
    ctx.fillRect(0, 0, stator_len, stator_width);
    ctx.fillStyle = "black";
    ctx.fillText("S", stator_len/2 , stator_width - (stator_width - letter_height * 1.25));
    ctx.fill();
    ctx.rect(0, 0, stator_len, stator_width);
    ctx.strokeStyle = "black";
    ctx.stroke();
    ctx.translate(0, stator_width / 2);
    ctx.rotate(-stator_angle_rad - Math.PI);

    // le pôle nord
    ctx.rotate(stator_angle_rad);
    ctx.translate(0, -stator_width / 2);
    ctx.beginPath();
    ctx.fillStyle = "red"; // rouge
    ctx.strokeStyle = "black";
    ctx.fillRect(0, 0, stator_len, stator_width);
    ctx.fillStyle = "black";
    ctx.fillText("N", stator_len/2, stator_width - (stator_width - letter_height * 1.25));
    ctx.fill();
    ctx.rect(0, 0, stator_len, stator_width);
    ctx.strokeStyle = "black";
    ctx.stroke();
    ctx.translate(0, stator_width / 2);
    ctx.rotate(-stator_angle_rad);

    // dessiner le centre
    ctx.beginPath();
    var line_long = R / 10;
    ctx.strokeStyle = "black";
    ctx.lineWidth = l_width;
    ctx.moveTo(-line_long / 2, 0);
    ctx.lineTo(line_long / 2, 0);
    ctx.moveTo(0, -line_long / 2);
    ctx.lineTo(0, line_long / 2);
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, R / 30, 0, 2 * Math.PI);
    ctx.stroke();
}

function draw_sinus_alternateur(ctx, Rr, R, ph1) {

    var ph2 = (ph1 % 360).toFixed();
    ph = 360;
    document.getElementById("txt_deg_id").innerHTML = "φ = " + ph2 + "˚";

    // draw box
    ctx.translate(Rr * 1.1, -R);
    ctx.beginPath();
    ctx.strokeStyle = "black";
    ctx.fillStyle = "#ffffe6"; // jaune clair
    ctx.fillRect(0, 0, 4.2 * R, 2 * R);
    ctx.lineWidth = l_width / 2;
    ctx.strokeRect(0, 0, 4.2 * R, 2 * R);
    ctx.translate(-Rr * 1.1, R);

    //draw axes
    ctx.translate(Xmin, -Ymin);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    draw_arrow(ctx, 0, 0, 1.05 * Xmax, Ymin);
    ctx.moveTo(0, 0);
    draw_arrow(ctx, 0, 0, 0, -Ymax * 1.05);
    ctx.moveTo(0, 0);
    draw_arrow(ctx, 0, 0, 0, Ymax * 1.05);
    ctx.moveTo(0, 0);
    ctx.stroke();
    ctx.translate(-Xmin, Ymin);

    //draw x graduations 
    ctx.translate(Xmin, -Ymin);
    ctx.beginPath();
    ctx.lineWidth = l_width / 2;
    var letter_height = l_width * 12;
    var letter_style = "normal " + letter_height + "px San serif";
    ctx.font = letter_style;
    ctx.textAlign = "center";
	ctx.textStyle = label_text_color;
	ctx.fillStyle = label_text_color;
    for (var i = 1; i != 9; i++) {
        var Xgrad = i * (Xmin + Xlen) / 8;
        ctx.moveTo(Xgrad, -gradLen);
        ctx.lineTo(Xgrad, gradLen);
		if (valeurs_YN) {
			ctx.fillText(45 * i, Xgrad, 4 * gradLen);
		}
    }
    Xgrad = 8.3 * (Xmin + Xlen) / 8;
	if (valeurs_YN) {
		ctx.fillText("φ[º]", Xgrad, 5 * gradLen);
	}
	
    ctx.moveTo(0, 0);
    ctx.stroke();
    ctx.translate(-Xmin, Ymin);

    //draw y graduations 
    ctx.translate(Xmin, -Ymin);
    ctx.beginPath();
    ctx.lineWidth = l_width / 2;
    letter_height = (l_width * 12).toFixed();
    letter_style = "normal " + letter_height + "px San serif";
    ctx.font = letter_style;
    ctx.textAlign = "center";
    for (i = -4; i != 5; i++) {
        var Ygrad = i * Ymax / 4;
        ctx.moveTo(-gradLen, Ygrad);
        ctx.lineTo(gradLen, Ygrad);
	ctx.textStyle = label_text_color;
	ctx.fillStyle = label_text_color;
		if (valeurs_YN) {
			ctx.fillText(-0.25 * i * u_crete, -5 * gradLen, Ygrad + gradLen / 2);
		}
    }
	Ygrad = -4 * Ymax / 4;
	ctx.fillText("U[V]", +6 * gradLen, (Ygrad - gradLen ));
				
    ctx.moveTo(0, 0);
    ctx.stroke();
    ctx.translate(-Xmin, Ymin);

    // draw sinus phase 1
    ctx.translate(Xmin, -Ymin);
    var Xold = 0.0;
    var Yold = 0.0;
    var Xnew = 0.0;
    var Ynew = 0.0;
    ctx.beginPath();
    ctx.lineWidth = l_width * 1;
    //phase 1
    ctx.strokeStyle = ph1_color;
    for (i = 0; i < ph; i++) {
        // console.log(i, ph, i-ph, Math.sign(i-ph));
        Xnew = i * (Xmin + Xlen) / 360;
        var Yrad = i * Math.PI / 180;
        var Ysin = -Math.sin(Yrad);
        Ynew = Ysin * Ymax;
        ctx.moveTo(Xold, Yold);
        ctx.lineTo(Xnew, Ynew);
        Xold = Xnew;
        Yold = Ynew;
    }
    ctx.stroke();
    if (!monophase_YN) {
        //phase 2
        ctx.moveTo(0, 0);
        Xold = 0;
        Yold = -Math.sin(2 / 3 * Math.PI) * Ymax;
        ctx.beginPath();
        ctx.lineWidth = l_width * 1;
        ctx.strokeStyle = ph3_color;
        for (i = 0; i < ph; i++) {
            // console.log(i, ph, i-ph, Math.sign(i-ph));
            Xnew = i * (Xmin + Xlen) / 360;
            Yrad = i * Math.PI / 180;
            Ysin = -Math.sin(Yrad + 2 / 3 * Math.PI);
            Ynew = Ysin * Ymax;
            ctx.moveTo(Xold, Yold);
            ctx.lineTo(Xnew, Ynew);
            Xold = Xnew;
            Yold = Ynew;
        }
        ctx.stroke();
        //phase 3
        ctx.moveTo(0, 0);
        Xold = 0;
        Yold = -Math.sin(4 / 3 * Math.PI) * Ymax;
        ctx.beginPath();
        ctx.lineWidth = l_width * 1;
        ctx.strokeStyle = ph2_color;
        for (i = 0; i < ph; i++) {
            // console.log(i, ph, i-ph, Math.sign(i-ph));
            Xnew = i * (Xmin + Xlen) / 360;
            Yrad = i * Math.PI / 180;
            Ysin = -Math.sin(Yrad + 4 / 3 * Math.PI);
            Ynew = Ysin * Ymax;
            ctx.moveTo(Xold, Yold);
            ctx.lineTo(Xnew, Ynew);
            Xold = Xnew;
            Yold = Ynew;
        }
        ctx.stroke();
        ctx.moveTo(0, 0);
		
        ctx.stroke();
		
    }
    ctx.translate(-Xmin, Ymin);

    // draw dots phase 1
    ctx.translate(Xmin, -Ymin);
    ctx.beginPath();
    ctx.fillStyle = ph1_color;
    Xnew = ph2 * (Xmin + Xlen) / 360;
    Yrad = ph2 * Math.PI / 180;
    Ysin = -Math.sin(Yrad);
    Ynew = Ysin * Ymax;
    ctx.arc(Xnew, Ynew, w / 2, 0, 2 * Math.PI);
    if (Math.abs(Ysin) < 0.001) {
        Ysin = 0;
    }
	var u_ph1 = u_crete * Ysin;
	
	document.getElementById("txt_ph1_id").innerHTML = "U=" + -(u_crete * Ysin).toPrecision(3)+ "V";
    ctx.fill();
    // draw_sin cos lines
    if (lines_YN) {
        ctx.strokeStyle = ph1_color;
        ctx.lineWidth = 1;
        ctx.setLineDash([3]);
        ctx.moveTo(Xnew, 0);
        ctx.lineTo(Xnew, Ynew);
        ctx.moveTo(Xnew, Ynew);
        ctx.lineTo(0, Ynew);
        ctx.fill();
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.moveTo(0, 0);
    }

    if (!monophase_YN) {
        // draw dots phase 2
        ctx.beginPath();
        ctx.fillStyle = ph3_color;
        Xnew = ph2 * (Xmin + Xlen) / 360;
        Yrad = ph2 * Math.PI / 180;
        Ysin = -Math.sin(Yrad + 2 / 3 * Math.PI);
        Ynew = Ysin * Ymax;
        ctx.arc(Xnew, Ynew, w / 2, 0, 2 * Math.PI);
        if (Math.abs(Ysin) < 0.001) {
            Ysin = 0;
        }
		var u_ph2 = u_crete * Ysin;
		
		document.getElementById("txt_ph3_id").innerHTML = "U=" + -(u_crete * Ysin).toPrecision(3)+ "V";
        ctx.fill();
        // draw_sin cos lines
        if (lines_YN) {
            ctx.strokeStyle = ph3_color;
            ctx.lineWidth = 1;
            ctx.setLineDash([3]);
            ctx.moveTo(Xnew, 0);
            ctx.lineTo(Xnew, Ynew);
            ctx.moveTo(Xnew, Ynew);
            ctx.lineTo(0, Ynew);
            ctx.fill();
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.moveTo(0, 0);
        }

        // draw dots phase 3
        ctx.beginPath();
        ctx.fillStyle = ph2_color;
        Xnew = ph2 * (Xmin + Xlen) / 360;
        Yrad = ph2 * Math.PI / 180;
        Ysin = -Math.sin(Yrad + 4 / 3 * Math.PI);
        Ynew = Ysin * Ymax;
        ctx.arc(Xnew, Ynew, w / 2, 0, 2 * Math.PI);
        if (Math.abs(Ysin) < 0.001) {
            Ysin = 0;
        }
		var u_ph3 = u_crete * Ysin;
		
		 document.getElementById("txt_ph2_id").innerHTML = "U=" + -(u_crete * Ysin).toPrecision(3)+ "V";
        ctx.fill();
        // draw_sin cos lines
        if (lines_YN) {
            ctx.strokeStyle = ph2_color;
            ctx.lineWidth = 1;
            ctx.setLineDash([3]);
            ctx.moveTo(Xnew, 0);
            ctx.lineTo(Xnew, Ynew);
            ctx.moveTo(Xnew, Ynew);
            ctx.lineTo(0, Ynew);
            ctx.fill();
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.moveTo(0, 0);
        }
    }
    ctx.translate(-Xmin, Ymin);

}

// ************************************************************************
// fonctions utilitaires
// ************************************************************************

// draw arrow lines
function draw_arrow(ctx, fromx, fromy, tox, toy) {
    const headlen = 10; // length of head in pixels
    var angle = Math.atan2(toy - fromy, tox - fromx);
    ctx.moveTo(fromx, fromy);
    ctx.lineTo(tox, toy);
    ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(tox, toy);
    ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
}

// ************************************************************************
// fonctions handling de l'animation
// ************************************************************************

// lancer la rotation automatique
function runMotor() {
    if (!anim_running) {
        idMotor = setInterval(animateRotor, sleep_time);
        anim_running = true;
        // stop_asked = false;
    } else {
        stop_asked = true;
    }
}

// fonction appelee par runMotor()
function animateRotor() {
    RefreshGraphAlternateur();
    p = p + p_inc;
    if (((p % 5) == 0) && stop_asked) {
        clearInterval(idMotor);
        anim_running = false;
        stop_asked = false;
    }
}

// faire un pas dans le sens positif
function stepRotorPlus() {
    if (!anim_running) {
        p = p + 1;
        RefreshGraphAlternateur();
    }
}

// faire un grand pas dans le sens positif
function stepRotorPlusPlus() {
    if (!anim_running) {
        p = p + 5;
        RefreshGraphAlternateur();
    }
}

// faire un pas dans le sens negatif
function stepRotorMoins() {
    if (!anim_running) {
        p = p - 1;
        if (p < 0) {
            p = 360 - 1;
        }
        RefreshGraphAlternateur();
    }
}

// faire un grand pas dans le sens negatif
function stepRotorMoinsMoins() {
    if (!anim_running) {
        p = p - 5;
        if (p < 0) {
            p = 360 - 5;
        }
        RefreshGraphAlternateur();
    }
}
function optLinesYesNo(value){
    lines_YN = !!value;
    RefreshGraphAlternateur();
}
function optMonophaseYesNo(value){
    monophase_YN = !!value;

    RefreshGraphAlternateur();
}
function optValeursYesNo(value){
    valeurs_YN = !!value;

    RefreshGraphAlternateur();
}


//]]>
//<![CDATA[
// procédures pour Moodle
function GoToMoodleHomePage()
{
    window.location.href="/"
}
//]]>
        </script>

<br/></body>
</html>

