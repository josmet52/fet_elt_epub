#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
fet_class.py
============
Cette classe contient toutes les procédures nécessaires au programme fet_main.py
Il doit se trouver dans le même directory que le programme fet_main.py
fichier : fet_class.py
utilisé par : fet_main.py
procédure de lancement : new_job
auteur : josmet
date : 21.06.2018
"""

import os
import subprocess
import time
import tkinter as tk
import uuid
import zipfile
import shutil

from datetime import datetime
from os import listdir
from os import walk
from os.path import isfile, join
from shutil import copyfile
from tkinter import *
from tkinter import filedialog
from tkinter import messagebox
from PIL import Image
from bs4 import BeautifulSoup

from fet_lib import ClasseFetLib
y = ClasseFetLib()
# from fet_xml_formatter import ClasseFetXmlFormatter
# f = ClasseFetLib()


class ClasseFet:
    """
        this class content all the fonctionnalities to improve the epub files generated by the Publiwide platform
            input :
                var_msg : to write message on the main window
                msg_list : listView where the messages are displayed
                msg_display : ref on the window where the message box is
            output :
                write the process steps in the information window
    """

    def __init__(self, var_msg, msg_list, msg_display, btn_frame):

        # Pseudo constantes
        self.DEBUG = False  # print debug messages
        self.LOG_THIS_RUN = True  # log debug messages

        # max size for the images in ppp
        self.IMG_SIZE_MAX = 20000
        # waiting another action finished
        self.ERROR_WAIT_TIME = 0.5
        self.LOG_FILE_NAME = "fet_log.txt"
        self.INI_FILE_NAME = "fet_epub.ini"
        self.CONTENT_OPF_FILE_NAME = "content.opf"

        #TOC
        self.TOC_DEEP = "h1+h2"
        self.FONT_NAME = "Comic sans MS"

        # initialisation variables
        self.var_msg = var_msg
        self.msg_list = msg_list
        self.msg_display = msg_display
        self.btn_frame = btn_frame
        # prepare the files info to display
        self.txt_in_file = "Sce file : "
        self.txt_out_file = "Dst file : "

        self.t_start = 0
        self.t_stop = 0
        self.pause_time = 2

        self.in_file_name = ""
        self.out_file_name = ""

        self.temp_path_dir = ""
        self.ops_dir = ""
        self.ops_path_dir = ""
        self.textPathDir = ""
        self.pw_path_dir = ""
        self.image_path_dir = ""
        self.content_path_file_name = ""
        self.in_path_file_name = ""
        self.out_path_file_name = ""
        self.log_fileName = ""
        self.log_path_file_name = ""
        self.style_file_name = ""
        self.style_path_file_name = ""
        self.style_exercices_path_file_name = ""
        self.style_pw_table_path_file_name = ""
        self.misc_path_file_name = ""
        self.nav_path_file_name = ""

        self.asked_2_quit = False

        # Current working directory
        self.cwd = "".join([str(os.getcwd()).replace("\\", "/").replace("\n", ""), "/"])
        # self.cwd = "".join([str(os.getcwd()).replace("\\" or "\n", "/"), "/"])

        # a file to log opérations
        self.log_path = "".join([self.cwd, "log/"])
        self.log_path_file_name = "".join([self.log_path, self.LOG_FILE_NAME])
        if not os.path.isdir(self.log_path):
            os.mkdir(self.log_path)


        self.nbre_passes = 0
        self.nbre_erreurs = 0
        self.second_try = 0

        self.program_in_test = False
        self.dir_job_status = False

        org_ok = False
        new_ok = False
        tmp_ok = False
        log_ok = False
        js_ok = False

        self.org_path = ""
        self.new_path = ""
        self.tmp_path = ""
        self.js_path = ""

        # constantes pour msg_display
        self.DISPLAY_ONLY = 1
        self.DISPLAY_AND_LOG = 2
        self.LOG_ONLY = 3

        self.COLOR_RED = 1
        self.COLOR_BLUE = 2
        self.COLOR_GREEN = 3
        self.COLOR_ORANGE = 5
        self.COLOR_PURPLE = 6
        self.COLOR_RED_ON_YELLOW = 4

        # init variables
        self.cwd = "".join([str(os.getcwd()).replace("\\", "/").replace("\n", ""), "/"])
        self.org_path = ""
        self.new_path = ""
        self.tmp_path = ""
        self.new_nav_path = ""
        self.new_js_path = ""
        self.new_moo_path = ""
        self.new_police_path = ""
        self.js_css_path = ""
        self.log_path = "".join([self.cwd, "log/"])
        self.log_path_file_name = "".join([self.log_path, self.LOG_FILE_NAME])

        # lecture des répertoires dans le fichier .ini
        self.ini_path_file_name = "".join([self.cwd, self.INI_FILE_NAME])
        if os.path.isfile(self.ini_path_file_name):

            with open(self.ini_path_file_name, "r", encoding="utf-8") as f_init:
                r = f_init.readlines()
                for p in r:
                    x = p.split("=")
                    x[0] = x[0].strip().lower()
                    if len(x) > 1 :
                        x[1] = x[1].strip().lower()

                        # ne pas traiter les commentaires
                        if x[0][:1] != "#":

                            if x[0] == "ini_org_dir":
                                self.org_path = "".join([x[1].replace("\"", ""), "/"]).replace("\n", "").replace(" ",
                                                    "").replace("//", "/")

                            elif x[0] == "ini_new_dir":
                                self.new_path = "".join([x[1].replace("\"", ""), "/"]).replace("\n", "").replace(" ",
                                                    "").replace("//", "/")

                            elif x[0] == "ini_tmp_dir":
                                self.tmp_path = "".join([x[1].replace("\"", ""), "/"]).replace("\n", "").replace(" ",
                                                    "").replace("//", "/")

                            elif x[0] == "ini_new_nav_dir":
                                self.new_nav_path = "".join([x[1].replace("\"", ""), "/"]).replace("\n", "").replace(" ",
                                                    "").replace("//", "/")

                            elif x[0] == "ini_new_js_css_dir":
                                self.new_js_path = "".join([x[1].replace("\"", ""), "/"]).replace("\n", "").replace(" ",
                                                    "").replace("//", "/")

                            elif x[0] == "ini_new_moodle_dir":
                                self.new_moo_path = "".join([x[1].replace("\"", ""), "/"]).replace("\n", "").replace(" ",
                                                    "").replace("//", "/")

                            elif x[0] == "ini_new_police_dir":
                                self.new_police_path = "".join([x[1].replace("\"", ""), "/"]).replace("\n", "").replace(" ",
                                                    "").replace("//", "/")

                            elif x[0] == "ini_js_css_ok_dir":
                                self.js_css_path = "".join([x[1].replace("\"", ""), "/"]).replace("\n", "").replace(" ",
                                                    "").replace("//", "/")

                            elif x[0] == "ini_var_debug" :
                                if x[1].replace("\n", "") == "true" : self.DEBUG = True
                                else : self.DEBUG = False

                            elif x[0] == "ini_var_log_this_run" :
                                if x[1].replace("\n", "") == "true" : self.LOG_THIS_RUN = True
                                else : self.LOG_THIS_RUN = False

                            elif x[0] == "ini_var_verbose" :
                                if x[1].replace("\n", "") == "true" : self.VERBOSE = True
                                else : self.VERBOSE = False

                            elif x[0] == "ini_var_with_dir" :
                                if x[1].replace("\n", "") == "true" : self.WITH_DIR = True
                                else : self.WITH_DIR = False

                            elif x[0] == "ini_var_with_zip" :
                                if x[1].replace("\n", "") == "true" : self.WITH_ZIP = True
                                else : self.WITH_ZIP = False

                            elif x[0] == "ini_var_img_size_max" :
                                if x[1].isnumeric() : self.IMG_SIZE_MAX = int(x[1])
                                else : self.IMG_SIZE_MAX = 20000

                            elif x[0] == "ini_var_toc_deep" :
                                self.TOC_DEEP = x[1]

                            elif x[0] == "ini_var_font" :
                                self.FONT_NAME = x[1]

            # if self.DEBUG:
            #     print("\n", "ORG_PATH", self.org_path, "\n", "NEW_PATH", self.new_path, "\n", "TEMP_PATH",
            #                      self.tmp_path, "\n", "LOG_PATH", self.log_path, "\n",
            #                      self.js_css_path, "\n")
            # if not (org_ok and new_ok and tmp_ok and log_ok and js_css_ok):
            #     msg_info = "".join(["Le fichier fet_epub.ini n'est pas complet ou comporte des erreurs. \n"
            #                         "Il doit definir les répertoires \n"
            #                         "org_dir: qui contient les fichiers source\n"
            #                         "new_dir: qui est le répertoire de sortie des fichiers modifiés\n"
            #                         "tmp_dir: qui est le répertoire temporaire\n"
            #                         "js_dir: qui est le répertoire des fichiers java script\n\n"
            #                         "Le programme se termine ici.\n"
            #                         "Corrigez le fichier .ini et relancez le programme.\n\n"
            #                         "Les entrées sont de la forme :\n"
            #                         "logDir=\"C:/Users/jmetr/_data/mandats/FET_new/fet_elt_epub/epubs/log\""])
            #     messagebox.showerror("Fichier ini défectueux \n", msg_info, icon='error')
            #     exit()

            if not os.path.isdir(self.new_path):
                os.mkdir(self.new_path)
            if not os.path.isdir(self.tmp_path):
                os.mkdir(self.tmp_path)
            if not os.path.isdir(self.org_path):
                msg_info = "".join([
                                "Le répertoire d'entrée org_dir n'existe pas\n" 
                                "ou le fichier fet_epub.ini n'est pas complet ou comporte des erreurs. "
                                "veuillez corriger le problème avant de relancer le programme\n\n" 
                                "Le fichier fet_epub.ini doit se trouver dans le répertoire de lancement de l'application "
                                "et doit definir les répertoires suivants\n\n"
                                "org_dir: qui contient les fichiers epub à travailler (entrée)\n"
                                "new_dir: qui est le répertoire de sortie des fichiers modifiés\n"
                                "tmp_dir: qui est le répertoire de travail temporaire\n"
                                "js_dir: qui est le répertoire des fichiers java script\n\n"
                                "Les entrées sont de la forme :\n"
                                "logDir=\"C:/Users/jmetr/_data/mandats/FET_new/fet_elt_epub/epubs/log\""
                                "\nLe programme se termine ici.\n"])
                messagebox.showerror("Fichier ini défectueux \n", msg_info, icon='error')
                messagebox.showerror("Fichier ini défectueux \n", msg_info, icon='error')
            if not os.path.isdir(self.js_css_path):
                msg_info = "".join([
                                "Le répertoire d'entrée js_dir n'existe pas\n" 
                                "ou le fichier fet_epub.ini n'est pas complet ou comporte des erreurs. "
                                "veuillez corriger le problème avant de relancer le programme\n\n" 
                                "Le fichier fet_epub.ini doit se trouver dans le répertoire de lancement de l'application "
                                "et doit definir les répertoires suivants\n\n"
                                "org_dir: qui contient les fichiers epub à travailler (entrée)\n"
                                "new_dir: qui est le répertoire de sortie des fichiers modifiés\n"
                                "tmp_dir: qui est le répertoire de travail temporaire\n"
                                "js_dir: qui est le répertoire des fichiers java script\n\n"
                                "Les entrées sont de la forme :\n"
                                "logDir=\"C:/Users/jmetr/_data/mandats/FET_new/fet_elt_epub/epubs/log\""
                                "\nLe programme se termine ici.\n"])
                messagebox.showerror("Fichier ini défectueux \n", "".join([msg_info]), icon='error')
                quit()

            n_epub = 0
            for files in os.listdir(self.org_path):
                if not os.path.isdir(self.org_path + files):
                    f = files.split(".")
                    if f[1] == "epub":
                        n_epub += 1
            if n_epub == 0:
                msg = "Il n\'y a pas de fichier epub dans le répertoire d\'entrée orgPath\n" \
                      "Le programme va se fermer!\n\n" \
                      "Corrigez le chemin des fichiers d'entrée puis relancez le programme."
                messagebox.showerror("Fichier ini défectueux \n", msg, icon='error')
                quit()
        else:
            msg = "".join(["Le fichier fet_epub.ini doit se trouver dans le répertoire de lancement de l'application.\n"
                           "Déplacez le fichier dans le bon répertoire et relancez l'application.\n\n"
                           "Le programme va se fermer."])
            messagebox.showerror("Fichier ini manquant \n", msg, icon='error')
            quit()

    def file_improve_pw_epub(self):
        """
            Here will be started the operations needed to
            improve the quality of the epubs generated by the Publiwide platform.
            input : none
            return : none
        """

        # disable all buttons that can not be used during this task
        self.manage_buttons("btnFileJob", "in")

        self.var_msg.set("")
        self.program_in_test = False

        # clear the listbox
        self.msg_list.delete(0, END)
        self.msg_display.update()

        # ask for the filename to work with
        self.in_path_file_name = filedialog.askopenfilename(title="Sélectionnez le fichier epub à améliorer",
                                                         initialdir=self.org_path,
                                                         filetypes=[('epub files', '.epub'), ('all files', '.*')])
        # if the len of filename is not = to 0 start the job
        if len(str(self.in_path_file_name)) > 0:
            self.t_start = time.time()  # store the start time
            self.in_file_name = os.path.basename(self.in_path_file_name)
            self.improve_epub()  # start the optimisation
        else:
            self.msg_list.insert(tk.END, "Select a epub to improve")
            self.msg_display.update()
        # enable all buttons
        self.manage_buttons("btnFileJob", "out")

    def verify_job(self):
        """
            This function checks an epub file based on the java epubcheck software of the international digital publishing forum
            input : none
            return : none
        """
        # disable all buttons that can not be used during this task
        self.manage_buttons("btnVerif", "in")
        # clear the listbox
        self.msg_list.delete(0, END)
        self.msg_display.update()

        epub_check_dir = "".join([self.cwd, "epubcheck/"])
        epub_check_file = "epubcheck.jar"
        java_epub_check_path_file_name = "".join([epub_check_dir, epub_check_file])

        # check if the java validation program is present
        if not os.path.isfile(java_epub_check_path_file_name):
            msg_info = "".join([
                            "Le répertoire contenant le programme de validation java n'existe pas. "
                            "Il doit se trouver dans le répertoire de "
                            "lancement de l'application. Il peut être téléchargé sur le site internet : "
                            "https://github.com/idpf/epubcheck et doit se nommer epubcheck\n\n"
                            "Veuillez corriger le problème avant de relancer le programme\n\n" 
                            "Le programme se termine ici.\n"])
            messagebox.showerror("Fichier ini défectueux \n", "".join([msg_info]), icon='error')
            sys.exit()

        # ask for the filename to work with
        self.in_file_name = filedialog.askopenfilename(title="Sélectionnez le fichier epub à vérifier",
                                                     initialdir=self.new_path,
                                                     filetypes=[('epub files', '.epub'), ('all files', '.*')])
        if len(str(self.in_file_name)) > 0:

            self.t_start = time.time()  # store the start time

            self.manage_info("---------------------------------------------------------", self.LOG_ONLY, self.COLOR_BLUE)
            self.manage_info("".join(["VERIFICATION EPUB : ", datetime.now().strftime("%Y%m%d-%H%M%S")]), self.LOG_ONLY, self.COLOR_BLUE)
            self.manage_info("".join(["Fichier : ", os.path.basename(self.in_file_name)]), self.DISPLAY_AND_LOG, self.COLOR_BLUE)
            self.manage_info("en cours de vérification. Patientez SVP ...", self.DISPLAY_AND_LOG, self.COLOR_BLUE)

            # execution de l'application java
            out_file_name = "".join([self.log_path, "epub_verif.xml"])
            f_ok, n_err, n_fatal, n_error, n_warn, epub_status = self.w3c_epub_check (self.in_file_name, out_file_name)
            # inscrire les résultats en clair dans le fichier txt de sortie
            with open("".join([self.log_path, "epub_prob.txt"]), "w", encoding="utf-8") as prob_file:
                # msg = "".join([self.in_file_name, "\n"])
                # prob_file.write(msg)
                for l in epub_status:
                    prob_file.write(l)
            elapsed_time = time.time() - self.t_start
            self.msg_list.delete(0, END)
            self.msg_display.update()

            # the result of the analyse to the user
            if f_ok:
                # all is ok
                self.t_stop = time.time()
                msg = "".join(["Statut du EPUB : ", os.path.basename(self.in_file_name),
                               "\n\nFélicitations aucun problème constaté : ", "EPUB OK", "\n",
                               "Fichier analysé en: ", str(int(elapsed_time)), "s\n"])
                messagebox.showinfo("Résultat de l'analyse \n", msg, icon='info')
                msg = "".join(
                    ["Félicitations aucun problème constaté dans le fichier : ", os.path.basename(self.in_file_name)])
                self.manage_info(msg, self.DISPLAY_AND_LOG, self.COLOR_GREEN)
            else:
                # there is problesm(s)
                msg_msgbox = "".join(
                    ["Statut du EPUB : ", os.path.basename(self.in_file_name), "\n\n", "EPUB PAS OK : ", str(n_err),
                     " problèmes constatés : ", "\n",
                     str(n_warn), " warning(s) - ", str(n_error), " error(s) - ", str(n_fatal), " fatal(s)\n",
                     "Fichier analysé en: ", str(int(elapsed_time)), "s\n",
                     "Détails des résultats dans le fichier : ", out_file_name, "\n\nVoulez-vous afficher le détail ?"])
                result = messagebox.askyesno("Résultat de l'analyse \n", msg_msgbox, icon='error')

                if result:
                    # the user clicked on yes to see the file
                    cmd = "".join(["notepad ", self.log_path, "epub_prob.txt"])
                    os.system(cmd)

                msg_info = "".join(
                    ["Fichier : ", os.path.basename(self.in_file_name), " ", str(n_err), " problèmes constatés : ",
                     str(n_warn), " warning(s) - ", str(n_error), " error(s) - ", str(n_fatal), " fatal(s)"])
                self.manage_info(msg_info, self.DISPLAY_AND_LOG, self.COLOR_RED_ON_YELLOW)
            self.manage_info("---------------------------------------------------------\n", self.LOG_ONLY, self.COLOR_BLUE)
        else:
            # no file selected so do nothing
            self.manage_info("Select a epub to verify", self.DISPLAY_ONLY, self.COLOR_RED_ON_YELLOW)
        self.manage_buttons("btnVerif", "out")

    def check_epub(self, in_path_file_name, out_path_file_name):

        # epub_check_dir = "".join([self.cwd, "epubcheck/"])
        # epub_check_file = "epubcheck.jar"
        # java_epub_check_path_file_name = "".join([epub_check_dir, epub_check_file])

        # execution de l'application java
        out_file_name = "".join([self.log_path, "epub_verif.xml"])
        f_ok, n_err, n_fatal, n_error, n_warn, epub_status = self.w3c_epub_check (in_path_file_name, out_file_name)

        #     # inscrire les résultats en clair dans le fichier txt de sortie
        with open(out_path_file_name, "a", encoding="utf-8") as prob_file:
            msg = "".join(["============================================================================================ \n"])
            prob_file.write(msg)
            for l in epub_status:
                prob_file.write(l)
        return "".join(["Check status : ",str(n_fatal), " fatal / ", str(n_error), " errors / ", str(n_warn), " warnings"]), n_fatal, n_error,  n_warn


    def dir_improve_pw_epub(self):

        """
        Cette fonction permet de vérifier tous les epub's contenus dans un répertoire
        Elle parcoure le répertoire choisi, vérifie qu'il y ait bien des fichiers epub puis,
        pour chaque ficheir epub, elle appelle la fonction file_improve_job pour exécuter l'amélioration de façon individelle
        """
        # variable qui permet de savoir si l'utilisateur a demandé à interrompre la procédure
        self.asked_2_quit = False
        # disable all buttons that can not be used during this task
        self.manage_buttons("btnDirJob", "in")

        dirjob_tstart = time.time()
        # variable pour que la fonction sache que l'appel vient d'ici et gère les messages en conséquence
        self.dir_job_status = True
        # demande le nom du répertoire à travailler
        file_options = {}
        file_options['initialdir'] = self.org_path
        file_options['title'] = 'Please select a directory witch content epub files'
        dir_name = filedialog.askdirectory(**file_options)

        file_output_result_path_name = "".join([self.log_path, "epub_check_result.txt"])
        # with open(file_output_result_path_name, "w", encoding="utf-8") as prob_file:
            # YY = str(datetime.now().year)
            # MM = str(datetime.now().month)
            # DD = str(datetime.now().day)
            # hh = str(datetime.now().hour)
            # mm = str(datetime.now().minute)
            # ss = str(datetime.now().second)
            # compete_date_time = "".join([DD, ".", MM, ".", YY, " ", hh,":",mm,":", ss, "\n"])
            # prob_file.write(compete_date_time)
            # prob_file.write("".join([str(datetime.now()), "\n "]))

        # erreurs totales
        fatal_tot = 0
        error_tot = 0
        warn_tot = 0
        recap_tot = []

        # On controle que le répertoire n'est pas vide
        if dir_name != "":
            # only the .epub files
            only_epub_files = [f for f in listdir(dir_name) if isfile(join(dir_name, f))
                               and os.path.splitext(f)[1] == ".epub"]
            if len(only_epub_files) > 0:
                # there is .epub files
                for test_file in only_epub_files:
                    self.t_start = time.time()
                    self.in_path_file_name = "/".join([dir_name, test_file])
                    self.in_file_name = os.path.basename(self.in_path_file_name)
                    self.improve_epub()

                    self.manage_info("---------------------------------------------------------", self.LOG_ONLY, self.COLOR_PURPLE)
                    self.manage_info("".join(["VERIFICATION EPUB : ", datetime.now().strftime("%Y%m%d-%H%M%S")]), self.LOG_ONLY, self.COLOR_PURPLE)
                    self.manage_info("".join(["Fichier : ", os.path.basename(self.in_file_name)]), self.DISPLAY_AND_LOG, self.COLOR_PURPLE)
                    self.manage_info("en cours de vérification. Patientez SVP ...", self.DISPLAY_AND_LOG, self.COLOR_PURPLE)

                    ret_status, n_fatal, n_error,  n_warn = self.check_epub(self.out_path_file_name, file_output_result_path_name)
                    fatal_tot += n_fatal
                    error_tot += n_error
                    warn_tot += n_warn
                    recap_tot.append("".join([test_file, " : ",str(n_fatal), " fatals / ", str(n_error), " errors / ", str(n_warn), " warnings\n"]))

                    self.manage_info(ret_status, self.DISPLAY_AND_LOG, self.COLOR_PURPLE)
                    msg = " "
                    self.manage_info(msg, self.DISPLAY_AND_LOG)
                    if self.asked_2_quit:
                        break
                    else:
                        time.sleep(self.pause_time)

                msg_err = "".join(["Check status total : ", str(fatal_tot), " fatal / ", str(error_tot), " error / ", str(warn_tot), " warn"])
                if not self.asked_2_quit:
                    elapsed_time = int(time.time() - dirjob_tstart)
                    elapsed_min = elapsed_time // 60
                    elapsed_sec = elapsed_time % 60
                    if elapsed_min > 0 :
                        msg = "".join(["DIR job terminated with ok code in ", str(elapsed_min), " min ", str(elapsed_sec), " sec"])
                    else:
                        msg = "".join(["DIR job terminated with ok code in ", str(elapsed_sec), " sec"])
                    for r in recap_tot:
                        self.manage_info(r, self.DISPLAY_AND_LOG)
                    self.manage_info(msg_err, self.DISPLAY_AND_LOG)
                    self.manage_info(msg, self.DISPLAY_AND_LOG)

                    # self.manage_info(msg, self.DISPLAY_AND_LOG)
                    # self.manage_info(msg_err, self.DISPLAY_AND_LOG)
                else:
                    msg = "".join(["Job terminated by user !"])
                    self.manage_info(msg_err, self.DISPLAY_AND_LOG)
                    self.manage_info(msg, self.DISPLAY_AND_LOG, self.COLOR_RED_ON_YELLOW)
            else:
                # there is no .epub files
                messagebox.showinfo("Répertoire d'entrée \n", "Il n'y a pas de fichiers .epub dans ce répertoire. \nRefaites votre choix", icon='info')

        # rétablir l'état normal des boutons'
        self.manage_buttons("btnDirJob", "out")

    def test_soft(self):

        """
        This function is used to test the program by running the improve function as long as the user does not
        interrupt the process. The main goal is to test conflict management when accessing files. The ideal is
        to launch at the same time several occurrences of the application to create conflicts on file access.
        Initially many conflicts were created by the Zoolz application that makes backups as new files appear.
        Now the problem is known but not solved. The interim solution was to stop the Zoolz program.
        """

        self.nbre_passes = 0
        self.nbre_erreurs = 0
        self.second_try = 0
        # disable all buttons that can not be used during this task
        self.manage_buttons("btnTest", "in")
        self.program_in_test = False
        self.asked_2_quit = False
        epub_found = True

        dir_name = filedialog.askdirectory(initialdir=self.org_path, title='Please select a directory')
        if dir_name != "":
            while True:
                self.nbre_passes += 1

                only_epub_files = [f for f in listdir(dir_name) if isfile(join(dir_name, f))
                                   and os.path.splitext(f)[1] == ".epub"]
                if len(only_epub_files) > 0:

                    only_files = [f for f in listdir(dir_name) if isfile(join(dir_name, f))]
                    for test_file in only_files:
                        v_msg = ("".join([self.var_msg.get(), "Passes : ", str(self.nbre_passes), " / 2nd try : ",
                                          str(self.second_try), " / Erreurs : ", str(self.nbre_erreurs), "\n"]))
                        self.msg_list.delete(0, END)
                        self.msg_list.insert(tk.END, "*********************************************************")
                        self.msg_list.itemconfig(tk.END, fg='red')
                        self.msg_list.itemconfig(tk.END, bg='lightgreen')
                        self.msg_list.insert(tk.END, v_msg)
                        self.msg_list.itemconfig(tk.END, fg='red')
                        self.msg_list.itemconfig(tk.END, bg='lightgreen')
                        self.msg_list.insert(tk.END, "*********************************************************")
                        self.msg_list.itemconfig(tk.END, fg='red')
                        self.msg_list.itemconfig(tk.END, bg='lightgreen')
                        self.msg_list.see("end")
                        self.msg_display.update()
                        time.sleep(self.pause_time)
                        self.t_start = time.time()
                        self.in_path_file_name = "/".join([dir_name, test_file])
                        self.in_file_name = os.path.basename(self.in_path_file_name)
                        self.improve_epub()
                        if self.asked_2_quit:
                            break
                        else:
                            time.sleep(self.pause_time)
                    if self.asked_2_quit:
                        break
                else:
                    # there is no .epub files
                    messagebox.showinfo("Répertoire d'entrée \n", "Il n'y a pas de fichiers .epub dans ce répertoire. \nRefaites votre choix", icon='info')
                    epub_found = False
                    break

        if epub_found:
            msg = "".join(["Job terminated by user !"])
            self.manage_info(msg, self.DISPLAY_AND_LOG, self.COLOR_RED_ON_YELLOW)
        else:
            self.msg_list.delete(0, END)
            msg = "".join(["Please select a task"])
            self.manage_info(msg, self.DISPLAY_AND_LOG, self.COLOR_BLUE)
        self.manage_buttons("btnTest", "out")

    def improve_epub(self):
        """
        This function is the heart of the program. It content all the operations in a sequence.
        - defines files names
        - defines directory and path
        - create a temporary directory
        - unzip the epub file in the temporary directory
        - do the next modifications
            #1 : copy images in the images directory
            #2 : resize images
            #3 : delete the empty html pages
            #4 : update the cover of the book
            #5 : import the french js validation script
            #6 : modify for using the french js script
            #7 : change the id of the title of the book
            #8 : add  new styles
            #9 : modify the head of the nav file
            #10 : put the title of nav in french
            #10a : rename nav.html to nav.xhtml
            for all th_ .html files
                #11 : change the word validation with validation_fr_jo
                #12 : change the <body style with <body
                #13a : correct the head of the text files for the new fet_styles
                #13b : correct the text for formulas
                #14 : correct the text for pw_reflow_elt
                #15 : correct the text for <div style=\"width
                #16 : remove scripts...
                #17 : correct the text for img files and insert img text in content.opf
            for all ex_ .html files
                #18a : correct the text for img files and insert img text in content.opf
                #18b : correct the text for img files and insert img text in content.opf
        - prettify html files
        - create and zip the new epub file
        - remove temporary files and directories
        - display infos on the executed process
        - end of the job
        """
        # go to the start dir
        os.chdir(self.cwd)

        # create the out_file_name with the in_file_name
        self.out_file_name = os.path.basename(self.in_file_name).replace(".epub", "_new.epub")
        # the out filename goes in the new directory
        self.out_path_file_name = "".join([self.new_path, self.out_file_name])
        # prepare the text to display in and out files
        self.txt_in_file = "".join(["Sce file : ", os.path.basename(self.in_path_file_name)])
        self.txt_out_file = "".join(["Dst file : ", self.out_file_name])

        # display the files status
        self.manage_info("===============================================================", self.DISPLAY_AND_LOG)
        self.manage_info("".join(["IMPROVE EPUB : ", datetime.now().strftime("%Y%m%d-%H%M%S")]), self.DISPLAY_AND_LOG)
        self.manage_info(self.txt_in_file, self.DISPLAY_AND_LOG, self.COLOR_BLUE)
        self.manage_info(self.txt_out_file, self.DISPLAY_AND_LOG, self.COLOR_BLUE)
        self.manage_info("===============================================================", self.LOG_ONLY)

        # search for a "unique directory name" and create the temp directory
        self.temp_path_dir = "".join([self.tmp_path, str(uuid.uuid4()), "/"])
        os.mkdir(self.temp_path_dir)
        if self.DEBUG:
            print("".join(["TEMP_PATHDIR : ", self.temp_path_dir]), 3)

        # unzip all files from inFileName to the extractDir
        self.manage_info("... unzip epub", self.DISPLAY_AND_LOG)
        with zipfile.ZipFile(self.in_path_file_name, "r") as z:
            z.extractall(self.temp_path_dir)

        # search for the name of the OPS directory (can be OEBPS or OPS)
        ok, self.ops_dir = self.get_ops_dir(self.temp_path_dir)
        if not ok:
            self.manage_info("get_ops_dir ERROR ... the programm give up", self.DISPLAY_AND_LOG)
        self.ops_path_dir = "".join([self.temp_path_dir, self.ops_dir])
        if self.DEBUG:
            print("".join(["OPS_PATHDIR : ", self.ops_path_dir]), 3)

        # path of the text directory
        self.text_path_dir = "".join([self.temp_path_dir, self.ops_dir, "Text/"])
        if self.DEBUG:
            print("".join(["TEXT_PATHDIR : ", self.text_path_dir]), 3)

        # path of the style directory
        self.style_file_name = "fet_styles.css"
        self.style_path_name = "".join([self.temp_path_dir, self.ops_dir, "Styles/"])
        self.style_path_file_name = "".join([self.temp_path_dir, self.ops_dir, "Styles/", self.style_file_name])
        self.style_exercices_path_file_name = "".join([self.temp_path_dir, self.ops_dir, "Styles/", "exercises.css"])
        self.style_pw_table_path_file_name = "".join(
            [self.temp_path_dir, self.ops_dir, "Styles/", "pw_table_style.css"])
        if self.DEBUG:
            print("".join(["STYLE_PATH_FILE_NAME : ", self.style_path_file_name]), 3)

        # path of the PW-add_cont directory
        self.pw_path_dir = "".join([self.temp_path_dir, self.ops_dir, "PW_add_cont/"])
        if self.DEBUG:
            print("".join(["PW_PATHDIR : ", self.pw_path_dir]), 3)

        # path of the Misc directory
        self.misc_path_file_name = "".join([self.temp_path_dir, self.ops_dir, "Misc/"])
        if self.DEBUG:
            print("".join(["MISC_PATHDIR : ", self.misc_path_file_name]), 3)

        # path of the images directory
        self.image_path_dir = "".join([self.temp_path_dir, self.ops_dir, "Images/"])
        if self.DEBUG:
            print("".join(["IMAGES_PATHDIR : ", self.image_path_dir]), 3)

        # path of the content.opf file
        self.content_path_file_name = "".join([self.temp_path_dir, self.ops_dir, self.CONTENT_OPF_FILE_NAME])
        if self.DEBUG:
            print("".join(["CONTENT_PATH_FILE_NAME : ", self.content_path_file_name]), 3)

        # path of the nav.html file
        self.nav_path_file_name = "".join([self.text_path_dir, "nav.html"])
        if self.DEBUG:
            print("".join(["NAV_FILE_NAME : ", self.nav_path_file_name]), 3)

        # 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

        n_text_changes = 0
        n_images_changes = 0
        n_styles_changes = 0
        n_content_changes = 0
        n_nav_toc_changes = 0
        n_pages_deleted = 0
        tot_changes = 0
        change_no = 0

        msg = " ".join(["... corrections"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)

        # CHANGE #1
        # ===================
        # copiing images in the local image directory
        # in the Publiwide ePub the images are in the PW_add_cont directory and they must be in the Images directory
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = " ".join([change_str,"... copying", "images files from PW_add_cont to Images directory"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        n_images_changes += self.copy_images(self.pw_path_dir, self.image_path_dir)
        tot_changes += n_images_changes

        # CHANGE #2
        # ===================
        # resize image
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = " ".join([change_str, "... resizing", "img files to max", str(self.IMG_SIZE_MAX), "dots"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        n_images_changes += self.resize_img(self.image_path_dir, self.IMG_SIZE_MAX)
        tot_changes += n_images_changes

        # CHANGE #3
        # ===================
        # convert cmyk to rgb
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... converting cmyk images to rgb"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        n_images_changes += self.convert_cmyk_2_rgb(self.image_path_dir)
        tot_changes += n_images_changes

        # CHANGE #4
        # ===================
        # supprimer les pages html de théorie et d'exercices vides
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = " ".join([change_str, "... deleting", "empty pages"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        n_pages_deleted += self.del_empty_pages(self.ops_path_dir)
        tot_changes += n_pages_deleted

        # CHANGE #5
        # ===================
        # Modifier le cover du ebook
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... updating cover page"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        n_text_changes += self.update_cover("".join([self.text_path_dir, "cover.xhtml"]))
        tot_changes += n_text_changes

        # CHANGE #6a validation file
        # ===================
        # delete old_validation_script_line in content.opf
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... updating content.opf, deleting old_validation_fr lines"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "validation")
        tot_changes += n_changes
        n_content_changes += n_changes

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "validation_fr")
        tot_changes += n_changes
        n_content_changes += n_changes

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "validation_fr_jo")
        tot_changes += n_changes
        n_content_changes += n_changes

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "validation_fr_jo_v1r")
        tot_changes += n_changes
        n_content_changes += n_changes

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "validation_fr_jo-v2")
        tot_changes += n_changes
        n_content_changes += n_changes

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "validation_fr_jo_v2")
        tot_changes += n_changes
        n_content_changes += n_changes

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "validation_fr_jo_v02_00")
        tot_changes += n_changes
        n_content_changes += n_changes

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "validation_fr_jo_v02_01")
        tot_changes += n_changes
        n_content_changes += n_changes

        # CHANGE #6b
        # ===================
        # delte all validation.js files in the ebook
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... deleting old validation...js files in ebook"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)

        only_files = [f for f in listdir(self.misc_path_file_name) if isfile(join(self.misc_path_file_name, f))]
        for f in only_files:
            if "validation.js" in f or "validation_fr.js" in f or "validation_fr_jo.js" in f or "validation_fr_jo_v02_00.js" in f or "validation_fr_jo-v2.js" in f or "validation_fr_jo_v2.js" in f:
                os.remove(self.misc_path_file_name + f)
                n_changes += 1
        tot_changes += n_changes
        n_content_changes += n_changes

        # CHANGE #6c
        # ===================
        # copy the new js validation script in the ebook
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... importing validation_fr_jo_v02_01.js"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        sce_file = "".join([self.js_css_path, "validation_fr_jo_v02_01.js"])
        dst_file = "".join([self.misc_path_file_name, "validation_fr_jo_v02_01.js"])
        copyfile(sce_file, dst_file)
        n_styles_changes += 1
        tot_changes += 1

        # CHANGE #6d
        # ===================
        # adapt the content.opf for the new validation_fr_jo_v02_01.js file
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        txt2add = "    <item id='validation_fr_jo_v02_01.js' href='Misc/validation_fr_jo_v02_01.js' media-type='text/javascript'/>\n"
        v_return, n_changes = self.add_line("".join([self.ops_path_dir, "content.opf"]), "manifest", txt2add)
        msg = "".join([change_str, "... ops.html modified .validation_fr_jo_v02_01.js added ..."])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        if v_return != "":
            self.manage_info(v_return, self.DISPLAY_AND_LOG)
        n_content_changes += n_changes
        tot_changes += n_changes

        # CHANGE #7a fet_style file
        # ===================
        # delete old fet_style in content.opf
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... updating content.opf, deleting old_validation_fr lines"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "/fet_styles")
        tot_changes += n_changes
        n_content_changes += n_changes

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "/fet_style_v1r")
        tot_changes += n_changes
        n_content_changes += n_changes

        # CHANGE #7b
        # ===================
        # delte all fet_style...css files in the ebook
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        n_changes = 0
        msg = "".join([change_str, "... deleting ols validation...js files in ebook"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)

        only_files = [f for f in listdir(self.style_path_name) if isfile(join(self.style_path_name, f))]
        for f in only_files:
            if "fet_styles.css" in f or "fet_style_v1r.css" in f:
                os.remove(self.style_path_name + f)
                n_changes += 1
        tot_changes += n_changes
        n_content_changes += n_changes

        # # CHANGE #7c
        # # ===================
        # # copy the new css fet_style_v1r script in the ebook
        # change_no += 1
        # change_str = "   #" + str(change_no) + ": "
        # msg = "".join([change_str, "... importing fet_styles_v02_01.css"])
        # self.manage_info(msg, self.DISPLAY_AND_LOG)
        # sce_file = "".join([self.js_css_path, "fet_styles_v02_01.css"])
        # dst_file = "".join([self.style_path_name, "fet_styles_v02_01.css"])
        # copyfile(sce_file, dst_file)
        # n_styles_changes += 1
        # tot_changes += 1
        #
        # # CHANGE #7d
        # # ===================
        # # adapt the content.opf for the new fet_styles_v02_01.css file
        # change_no += 1
        # change_str = "   #" + str(change_no) + ": "
        # n_changes = 0
        # txt2add = "    <item id=\"fet_styles_v02_01.css\" href=\"Styles/fet_styles_v02_01.css\" media-type=\"text/css\"/>\n"
        # v_return, n_changes = self.add_line("".join([self.ops_path_dir, "content.opf"]), "manifest", txt2add)
        # msg = "".join([change_str, "... ops.html modified fet_style_v1r added ..."])
        # self.manage_info(msg, self.DISPLAY_AND_LOG)
        # if v_return != "":
        #     self.manage_info(v_return, self.DISPLAY_AND_LOG)
        # n_content_changes += n_changes
        # tot_changes += n_changes

        # CHANGE #8a pw_table_style.css
        # ===================
        # delete old pw_table_stale in content.opf
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... updating content.opf, deleting pw_table_style.ccs lines"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "/pw_table_style")
        tot_changes += n_changes
        n_content_changes += n_changes

        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, "/pw_table_style")
        tot_changes += n_changes
        n_content_changes += n_changes

        # CHANGE #8b
        # ===================
        # delte all pw_table_style...css files in the ebook
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        n_changes = 0
        msg = "".join([change_str, "... deleting old pw_table_style...js files in ebook"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)

        only_files = [f for f in listdir(self.style_path_name) if isfile(join(self.style_path_name, f))]
        for f in only_files:
            if "pw_table_style.css" in f or "pw_table_style_v1r.css" in f:
                os.remove(self.style_path_name + f)
                n_changes += 1
        tot_changes += n_changes
        n_content_changes += n_changes

        # # CHANGE #8c
        # # ===================
        # # copy the new css pw_table_style_v1r script in the ebook
        # change_no += 1
        # change_str = "   #" + str(change_no) + ": "
        # msg = "".join([change_str, "... importing pw_table_style_v02_01.css"])
        # self.manage_info(msg, self.DISPLAY_AND_LOG)
        # sce_file = "".join([self.js_css_path, "pw_table_style_v02_01.css"])
        # dst_file = "".join([self.style_path_name, "pw_table_style_v02_01.css"])
        # copyfile(sce_file, dst_file)
        # n_styles_changes += 1
        # tot_changes += 1
        #
        # # CHANGE #8d
        # # ===================
        # # adapt the content.opf for the new pw_table_style_v1r.css file
        # change_no += 1
        # change_str = "   #" + str(change_no) + ": "
        # n_changes = 0
        # txt2add = "    <item id=\"pw_table_style_v02_01.css\" href=\"Styles/pw_table_style_v02_01.css\" media-type=\"text/css\"/>\n"
        # v_return, n_changes = self.add_line("".join([self.ops_path_dir, "content.opf"]), "manifest", txt2add)
        # msg = "".join([change_str, "... ops.html modified pw_table_style_v02_00 added ..."])
        # self.manage_info(msg, self.DISPLAY_AND_LOG)
        # if v_return != "":
        #     self.manage_info(v_return, self.DISPLAY_AND_LOG)
        # n_content_changes += n_changes
        # tot_changes += n_changes


        # CHANGE #9
        # ===================
        # change the cover  item in content.opf
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... updating cover in content.opf"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        old_txt = "<item href=\"Text/cover.xhtml\" id=\"cover.xhtml\" media-type=\"application/xhtml+xml\"/>"
        new_txt = "<item href=\"Text/cover.xhtml\" id=\"cover.xhtml\" media-type=\"application/xhtml+xml\" properties=\"svg\"/>"
        v_return, n_changes = self.change_txt(self.content_path_file_name, old_txt, new_txt)
        tot_changes += n_changes
        n_content_changes += n_changes


        # CHANGE #10
        # ===================
        # change the id of the title
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... correcting the title of the book in content.opf"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        v_tag = "dc:title"
        old_title = self.get_id_value(self.content_path_file_name, v_tag)
        new_title = os.path.basename(self.in_file_name).replace(".epub", "").replace("_", " ")
        v_return, n_changes = self.change_txt(self.content_path_file_name, old_title, new_title)
        if v_return != "":
            self.manage_info(v_return, self.DISPLAY_AND_LOG)
        n_text_changes += n_changes
        tot_changes += n_changes

        # CHANGE #11
        # ===================
        # delete line with nav.html in content.opf <manifest>
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... deleting line with 'Text/nav.html' line in content.opf"])
        line2delete = "Text/nav.html"
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, line2delete)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        n_content_changes += n_changes
        tot_changes += n_changes

        # CHANGE #12
        # ===================
        # delete line in content.opf <spine>
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... deleting line with '<itemref idref=\"nav\"/>'in content.opf"])
        line2delete = "<itemref idref=\"nav\"/>"
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        v_return, n_changes = self.del_line_in_content_opf(self.content_path_file_name, line2delete)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        n_content_changes += n_changes
        tot_changes += n_changes

        # CHANGE #13
        # ===================
        # change the the type of  js files
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... correcting the type of js files in content.opf"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        old_type = "text/javascript"
        new_type = "application/javascript"
        v_return, n_changes = self.change_txt(self.content_path_file_name, old_type, new_type)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        n_content_changes += n_changes
        tot_changes += n_changes

        # CHANGE #14
        # ===================
        # change the the cover id in content.opf
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... changing \"cover-image\" in content=\"cover\" in content.opf"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        old_type = "content=\"cover-image\""
        new_type = "content=\"cover\""
        v_return, n_changes = self.change_txt(self.content_path_file_name, old_type, new_type)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        n_content_changes += n_changes
        tot_changes += n_changes

        # CHANGE #15
        # ===================
        # change the the type linear='no'  en linear='yes'
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... changing linear=no in linear=yes in content.opf"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        old_type = "linear=\"no\"/>"
        new_type = "linear=\"yes\"/>"
        v_return, n_changes = self.change_txt(self.content_path_file_name, old_type, new_type)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        n_content_changes += n_changes
        tot_changes += n_changes

        # CHANGE #16
        # ===================
        # change text-align for exercices.css
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... correcting the type of js files in content.opf"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        old_type = "text-align:initial;"
        new_type = "text-align:left;"
        v_return, n_changes = self.change_txt(self.style_exercices_path_file_name, old_type, new_type)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        n_styles_changes += n_changes
        tot_changes += n_changes

        # CHANGE #17
        # ===================
        # change background colors in pw_table_style
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... correcting background colors in pw_table_style"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        old_type = "background: linear-gradient(to right, #1eb2d7 , #c1e2f1 95%);"
        new_type = ""
        v_return, n_changes = self.change_txt(self.style_pw_table_path_file_name, old_type, new_type)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        n_styles_changes += n_changes
        tot_changes += n_changes

        # CHANGE #18
        # ===================
        # change -webkit-linear-gradient to backgrouncolor
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = "".join([change_str, "... correcting background colors in pw_table_style"])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        old_type = "background: -webkit-linear-gradient(left, #1eb2d7 ,#c1e2f1 95%);"
        new_type = "background-color: #1eb2d7;"
        v_return, n_changes = self.change_txt(self.style_pw_table_path_file_name, old_type, new_type)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        n_styles_changes += n_changes
        tot_changes += n_changes

        # CHANGE #19
        # ===================
        # add new styles
        # change_no += 1
        # change_str = "   #" + str(change_no) + ": "
        # n_changes = self.add_fet_style_line(self.style_path_file_name)
        # if n_changes > 0:
        #     msg = " ".join([change_str, self.content_path_file_name, str(n_styles_changes), "new styles added  ..."])
        #     self.manage_info(msg, self.LOG_ONLY)
        # if v_return != "":
        #     self.manage_info((v_return, self.DISPLAY_AND_LOG))
        # tot_changes += n_changes
        # n_styles_changes += n_changes

        # QUALITY IMPROVE #20
        # ===================
        # rename nav.html to nav.xhtml and update content.opf for that

        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        old_path_name = self.nav_path_file_name.replace("//", "/")
        if os.path.isfile(old_path_name):
            x = old_path_name.split(".")
            if x[1] == "html":
                new_path_name = "".join([x[0], ".x", x[1]])
                v_return = self.rename_file(old_path_name, new_path_name)
                msg = "".join([change_str, "... nav.html modified in nav.xhtml ..."])
                self.manage_info(msg, self.DISPLAY_AND_LOG)
                if v_return != "":
                    self.manage_info((v_return, self.DISPLAY_AND_LOG))
                n_nav_toc_changes += n_changes
                tot_changes += n_changes
                self.nav_path_file_name = new_path_name

                # self.content_path_file_name = "".join([self.ops_path_dir, "content.opf"])
                spine_found = False
                with open(self.content_path_file_name, "r", encoding="utf-8") as opf_file_readable:
                    opf_data = opf_file_readable.readlines()
                    opf_file_readable.close()
                with open(self.content_path_file_name, "w", encoding="utf-8") as opf_file_writable:
                    for l in opf_data:
                        l_new = l
                        if "</spine>" in l:
                            spine_found = False

                        if spine_found:
                            if "nav.html" in l:
                                l_new = l.replace("nav.html", "nav.xhtml")
                                n_content_changes += 1
                                tot_changes += 1

                        if "<spine" in l:
                            spine_found = True

                        opf_file_writable.write(l_new)
                    opf_file_writable.close()
        else:
            path_file = "".join([os.path.dirname(old_path_name), "/nav.xhtml"])
            if os.path.isfile(path_file):
                self.nav_path_file_name = path_file
            else:
                print("OUUUPS nav.xhtml not found")
                exit

        # QUALITY IMPROVE #21
        # ===================
        # add the nav line in <manifest>
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        txt2add = "<item id=\"nav.xhtml\" href=\"Text/nav.xhtml\" media-type=\"application/xhtml+xml\" properties=\"nav\"/>\n"
        to_add = True
        # check if text allready exist
        with open(self.content_path_file_name, "r", encoding="utf-8") as opf_file:
            xml_opf_lines = [x.strip() for x in opf_file.readlines()]
            opf_file.close()
        for line in xml_opf_lines:
            if line == txt2add:
                to_add = False
                break

        if to_add:
            v_return, n_changes = self.add_line(self.content_path_file_name, "manifest", txt2add)
            msg = "".join([change_str, "... ops.html modified <manifest> updated ..."])
            self.manage_info(msg, self.DISPLAY_AND_LOG)
            if v_return != "":
                self.manage_info((v_return, self.DISPLAY_AND_LOG))
            n_content_changes += n_changes
            tot_changes += n_changes

        # CHANGE #22
        # ===================
        # adapt the head of the nav file
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        txt2add = "<link href='../Styles/pw_table_style.css' rel='stylesheet' type='text/css'/>"
        v_return, n_changes = self.add_line(self.nav_path_file_name, "head", txt2add)
        msg = "".join([change_str, "... nav.html modified ./Styles/pw_table_style.css added ..."])
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        n_nav_toc_changes += n_changes
        tot_changes += n_changes

        # change 23
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        msg = " ".join([change_str, "... correcting the th_... and ex_... xhtml files"])
        change_str = "   -> #" + str(change_no) + ": "
        self.manage_info(msg, self.DISPLAY_AND_LOG)

        # for the files th_, ex_, con
        for (v_path, v_dirs, v_files) in walk(self.text_path_dir):
            for v_file in v_files:
                # if v_file[:3] in ["th_", "ex_", "con", "nav"]:
                if True: # v_file[:3] in ["th_", "ex_", "con", "pag"]:
                    v_file_path_name = "".join([v_path, v_file])

                    # QUALITY IMPROVE #23a
                    # ===================
                    # remove the h1 empty title in all .xhtml files
                    change_str = "   -> #" + str(change_no) + "a: "
                    v_return, n_changes = self.change_txt(v_file_path_name, "<h1><br/></h1>", "")
                    if n_changes > 0:
                        msg = " ".join([change_str, v_file, str(n_changes), "h1 empty titles removed"])
                        if self.VERBOSE:
                            self.manage_info(msg, self.DISPLAY_AND_LOG)
                        else:
                            self.manage_info(msg, self.LOG_ONLY)
                    if v_return != "":
                        self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    tot_changes += n_changes
                    n_text_changes += n_changes

                    # CHANGE #23b
                    # ===================
                    # delete all old validation reference in all .xhtml files
                    change_str = "   -> #" + str(change_no) + "b1: "
                    # print(v_file_path_name)
                    n_del = 0
                    v_return, n_changes = self.remove_txt(v_file_path_name, "<script src=\"../Misc/validation", "</script>")
                    n_del += n_changes
                    v_return, n_changes = self.remove_txt(v_file_path_name, "<script src=\"../Misc/validation_fr", "</script>")
                    n_del += n_changes
                    v_return, n_changes = self.remove_txt(v_file_path_name, "<script src=\"../Misc/validation_fr_jo", "</script>")
                    n_del += n_changes
                    v_return, n_changes = self.remove_txt(v_file_path_name, "<script src=\"../Misc/validation_fr_jo_v02_01", "</script>")
                    n_del += n_changes
                    v_return, n_changes = self.remove_txt(v_file_path_name, "<script src=\"../Misc/validation_fr_jo-v2", "</script>")
                    n_del += n_changes
                    v_return, n_changes = self.remove_txt(v_file_path_name, "<script src=\"../Misc/validation_fr_jo_v2", "</script>")
                    n_del += n_changes

                    if n_del > 0:
                        msg = " ".join([change_str, v_file, str(n_del), "correcting xhtml files for validation_fr_jo.js"])
                        if self.VERBOSE:
                            self.manage_info(msg, self.DISPLAY_AND_LOG)
                        else:
                            self.manage_info(msg, self.LOG_ONLY)
                    if v_return != "":
                        self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    tot_changes += n_del
                    n_text_changes += n_del

                    # insert the right validation reference in all .xhtml files
                    if n_del > 0:
                        change_str = "   -> #" + str(change_no) + "b2: "
                        txt_2_add = "<script src=\"../Misc/validation_fr_jo_v02_01.js\" type=\"text/javascript\"><!--empty--></script>\n"
                        v_return, n_changes = self.add_line(v_file_path_name, "head", txt_2_add)
                        if n_changes > 0:
                            msg = " ".join([change_str, v_file, str(n_changes), "correcting xhtml files for validation_fr_jo.js"])
                            if self.VERBOSE:
                                self.manage_info(msg, self.DISPLAY_AND_LOG)
                            else:
                                self.manage_info(msg, self.LOG_ONLY)
                        if v_return != "":
                            self.manage_info((v_return, self.DISPLAY_AND_LOG))
                        tot_changes += n_changes
                        n_text_changes += n_changes

                    # delete all old fet_styles reference in all .xhtml files
                    change_str = "   -> #" + str(change_no) + "b3: "
                    v_return, n_changes = self.remove_txt(v_file_path_name, "<link href=\"../Styles/fet_styles", "/>")
                    if n_changes > 0:
                        msg = " ".join([change_str, v_file, str(n_changes), "correcting xhtml files for fet_styles...css"])
                        if self.VERBOSE:
                            self.manage_info(msg, self.DISPLAY_AND_LOG)
                        else:
                            self.manage_info(msg, self.LOG_ONLY)
                    if v_return != "":
                        self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    tot_changes += n_changes
                    n_text_changes += n_changes

                    # insert the right fet_styles reference in all .xhtml files
                    # if n_changes > 0:
                    #     change_str = "   -> #" + str(change_no) + "b4: "
                    #     txt_2_add = "<link href=\"../Styles/fet_styles_v02_01.css\" rel=\"stylesheet\" type=\"text/css\"/>\n"
                    #     v_return, n_changes = self.add_line(v_file_path_name, "head", txt_2_add)
                    #     if n_changes > 0:
                    #         msg = " ".join([change_str, v_file, str(n_changes), "correcting xhtml files for fet_styles_v02_01.css"])
                    #         if self.VERBOSE:
                    #             self.manage_info(msg, self.DISPLAY_AND_LOG)
                    #         else:
                    #             self.manage_info(msg, self.LOG_ONLY)
                    #     if v_return != "":
                    #         self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    #     tot_changes += n_changes
                    #     n_text_changes += n_changes

                    # delete all old fet_styles reference in all .xhtml files
                    change_str = "   -> #" + str(change_no) + "b5: "
                    v_return, n_changes = self.remove_txt(v_file_path_name, "<link href=\"../Styles/pw_table_style", "/>")
                    if n_changes > 0:
                        msg = " ".join([change_str, v_file, str(n_changes), "correcting xhtml files for pw_table_style...css"])
                        if self.VERBOSE:
                            self.manage_info(msg, self.DISPLAY_AND_LOG)
                        else:
                            self.manage_info(msg, self.LOG_ONLY)
                    if v_return != "":
                        self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    tot_changes += n_changes
                    n_text_changes += n_changes

                    # insert the right fet_styles reference in all .xhtml files
                    # if n_changes > 0:
                    #     change_str = "   -> #" + str(change_no) + "b6: "
                    #     txt_2_add = "<link href=\"../Styles/pw_table_style_v02_01.css\" rel=\"stylesheet\" type=\"text/css\"/>\n"
                    #     v_return, n_changes = self.add_line(v_file_path_name, "head", txt_2_add)
                    #     if n_changes > 0:
                    #         msg = " ".join([change_str, v_file, str(n_changes), "correcting xhtml files for pw_table_style_v02_01.css"])
                    #         if self.VERBOSE:
                    #             self.manage_info(msg, self.DISPLAY_AND_LOG)
                    #         else:
                    #             self.manage_info(msg, self.LOG_ONLY)
                    #     if v_return != "":
                    #         self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    #     tot_changes += n_changes
                    #     n_text_changes += n_changes

                    # CHANGE #23c
                    # ===================
                    # change MathML declaration in all .xhtml files
                    change_str = "   -> #" + str(change_no) + "c: "
                    old_mathml_txt = "<math xmlns=\"http://www.w3.org/1998/Math/MathML\">"
                    new_mathml_txt = "<math xmlns=\"http://www.w3.org/1998/Math/MathML\" alttext=\"affichage de formules pas supporté par le logiciel\">"
                    v_return, n_changes = \
                        self.change_txt(v_file_path_name, old_mathml_txt, new_mathml_txt)
                    if n_changes > 0:
                        msg = " ".join([change_str, v_file, str(n_changes), "correcting xhtml files for MathML declaration"])
                        if self.VERBOSE:
                            self.manage_info(msg, self.DISPLAY_AND_LOG)
                        else:
                            self.manage_info(msg, self.LOG_ONLY)
                    if v_return != "":
                        self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    tot_changes += n_changes
                    n_text_changes += n_changes

                    # CHANGE #23d
                    # ===================
                    # delte the pw_add_cont in the path of file in all .xhtml files
                    change_str = "   -> #" + str(change_no) + "d: "
                    v_return, n_changes = self.change_txt(v_file_path_name, "../PW_add_cont/Misc/src", "../Misc")
                    if n_changes > 0:
                        msg = " ".join([change_str, v_file, str(n_changes), "correcting xhtml files for pw_add_cont"])
                        if self.VERBOSE:
                            self.manage_info(msg, self.DISPLAY_AND_LOG)
                        else:
                            self.manage_info(msg, self.LOG_ONLY)
                    if v_return != "":
                        self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    tot_changes += n_changes
                    n_text_changes += n_changes

                    # CHANGE #23e
                    # ===================
                    # delete the pw_add_cont in the path of file in all .xhtml files
                    change_str = "   -> #" + str(change_no) + "e: "
                    v_return, n_changes = self.change_txt(v_file_path_name, "../PW_add_cont/Misc", "../Misc")
                    if n_changes > 0:
                        msg = " ".join([change_str, v_file, str(n_changes), "correcting xhtml files for pw_add_cont"])
                        if self.VERBOSE:
                            self.manage_info(msg, self.DISPLAY_AND_LOG)
                        else:
                            self.manage_info(msg, self.LOG_ONLY)
                    if v_return != "":
                        self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    tot_changes += n_changes
                    n_text_changes += n_changes

                    # CHANGE #23f
                    # ===================
                    # change the <body style with <body in all .xhtml files
                    change_str = "   -> #" + str(change_no) + "f: "
                    v_return, n_changes = self.change_txt(v_file_path_name, "<body style=\"\">", "<body>")
                    if n_changes > 0:
                        msg = " ".join([change_str, v_file, str(n_changes), "correcting xhtml files for <body style= ..."])
                        if self.VERBOSE:
                            self.manage_info(msg, self.DISPLAY_AND_LOG)
                        else:
                            self.manage_info(msg, self.LOG_ONLY)
                    if v_return != "":
                        self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    tot_changes += n_changes
                    n_text_changes += n_changes

                    # CHANGE #23g
                    # ===================
                    # adapt the head of the text files for the new fet_styles
                    # change_str = "   -> #" + str(change_no) + "g: "
                    # txt2add = "<link href=\"../Styles/fet_styles.css\" rel=\"stylesheet\" type=\"text/css\"/>"
                    # v_return, n_changes = self.add_line(v_file_path_name, "head", txt2add)
                    # if n_changes > 0:
                    #     msg = " ".join([change_str, v_file, str(n_changes), "adapt the head of the text files for the new fet_styles"])
                    #     if self.VERBOSE:
                    #         self.manage_info(msg, self.DISPLAY_AND_LOG)
                    #     else:
                    #         self.manage_info(msg, self.LOG_ONLY)
                    # if v_return != "":
                    #     self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    # n_styles_changes += n_changes
                    # tot_changes += n_changes

                    # CHANGE #23h
                    # ===================
                    # in all xhtml files Images must begin with à capital letter I
                    change_str = "   -> #" + str(change_no) + "h: "
                    v_return, n_changes = self.change_txt(v_file_path_name, "images", "Images")
                    if n_changes > 0:
                        msg = " ".join([change_str, v_file, str(n_changes), "correcting xhtml files for <body style= ..."])
                        if self.VERBOSE:
                            self.manage_info(msg, self.DISPLAY_AND_LOG)
                        else:
                            self.manage_info(msg, self.LOG_ONLY)
                    if v_return != "":
                        self.manage_info((v_return, self.DISPLAY_AND_LOG))
                    tot_changes += n_changes
                    n_text_changes += n_changes

                    if "th_" in v_file:

                        # CHANGE #24a
                        # ===================
                        # change the adapt the text for formulas
                        change_str = "   -> #" + str(change_no) + "i: "
                        v_return, n_changes = self.change_formula(v_file_path_name, "<p><span>", "</p>",
                                                                  "<p class=\"fet_formula\"><span>", "</span></p><br/>")
                        if n_changes > 0:
                            msg = " ".join([change_str, v_file, str(n_changes), "inserting the use of the formula style ..."])
                            self.manage_info(msg, self.DISPLAY_AND_LOG)
                        if v_return != "":
                            tot_changes += n_changes
                            n_text_changes += n_changes
                            if self.VERBOSE:
                                self.manage_info(msg, self.DISPLAY_AND_LOG)
                            else:
                                self.manage_info(msg, self.LOG_ONLY)

                        # CHANGE #24b
                        # ===================
                        # change the adapt the text for pw_reflow_elt
                        change_str = "   -> #" + str(change_no) + "j: "
                        v_return, n_changes = self.comment_out_and_insert(v_file_path_name,
                                    "<div class=\"pw_reflow_elt\" id=\"pw_exercise_container", ">", "<div")
                        if n_changes > 0:
                            msg = " ".join([change_str, v_file, str(n_changes),
                                            "changind the <div class='pw_reflow_elt' id='pw_exercise_container ..."])
                            if self.VERBOSE:
                                self.manage_info(msg, self.DISPLAY_AND_LOG)
                            else:
                                self.manage_info(msg, self.LOG_ONLY)
                        if v_return != "":
                            self.manage_info((v_return, self.DISPLAY_AND_LOG))
                        tot_changes += n_changes
                        n_text_changes += n_changes

                        # CHANGE #24c
                        # ===================
                        # change the text for <div style="width
                        change_str = "   -> #" + str(change_no) + "k: "
                        v_return, n_changes = self.comment_out_and_insert(v_file_path_name, "<div style=\"width:",
                                                                          ";\">", "<div")
                        if n_changes > 0:
                            msg = " ".join([change_str, v_file, str(n_changes), "changind the <div style='width:  ..."])
                            self.manage_info(msg, self.DISPLAY_AND_LOG)
                        if v_return != "":
                            self.manage_info((v_return, self.DISPLAY_AND_LOG))
                        tot_changes += n_changes
                        n_text_changes += n_changes

                        # CHANGE #24d
                        # ===================
                        # remove scripts
                        change_str = "   -> #" + str(change_no) + "l: "
                        v_return, n_changes = self.remove_txt(v_file_path_name, "<script data-pw-script=", "</script>")
                        if n_text_changes > 0:
                            msg = " ".join([change_str, v_file, str(n_text_changes), "removing the <script data-pw-script=  ..."])
                            if self.VERBOSE:
                                self.manage_info(msg, self.DISPLAY_AND_LOG)
                            else:
                                self.manage_info(msg, self.LOG_ONLY)
                        if v_return != "":
                            self.manage_info((v_return, self.DISPLAY_AND_LOG))
                        tot_changes += n_changes
                        n_text_changes += n_changes

                        # CHANGE #24e
                        # ===================
                        # adapt text in th_ files and insert img text in content.opf
                        change_str = "   -> #" + str(change_no) + "m: "
                        v_return, n_changes = self.change_img(v_file_path_name, self.ops_path_dir, "<img class=", "/>")
                        if n_changes > 0:
                            msg = " ".join(
                                [change_str, v_file, str(n_changes), "adapt text and content.opf for images in th_ files  ..."])
                            if self.VERBOSE:
                                self.manage_info(msg, self.DISPLAY_AND_LOG)
                            else:
                                self.manage_info(msg, self.LOG_ONLY)
                        if v_return != "":
                            self.manage_info((v_return, self.DISPLAY_AND_LOG))
                        tot_changes += n_changes
                        n_text_changes += n_changes

                    if "ex_" in v_file:

                        # CHANGE #25a
                        # ===================
                        # adapt text in ex_ files and insert img text in content.opf
                        change_str = "   -> #" + str(change_no) + "n: "
                        v_return, n_changes = self.change_img(v_file_path_name, self.ops_path_dir,
                                                              "<img src=\"../PW_add_cont", "/>")
                        if n_changes > 0:
                            msg = " ".join(
                                [change_str, v_file, str(n_changes), "change <img src='../PW_add_cont in ex_ files  ..."])
                            if self.VERBOSE:
                                self.manage_info(msg, self.DISPLAY_AND_LOG)
                            else:
                                self.manage_info(msg, self.LOG_ONLY)
                        if v_return != "":
                            self.manage_info((v_return, self.DISPLAY_AND_LOG))
                        tot_changes += n_changes
                        n_text_changes += n_changes

                        # CHANGE #25b
                        # ===================
                        # adapt text in ex_ files and insert img text in content.opf
                        change_str = "   -> #" + str(change_no) + "o: "
                        v_return, n_changes = self.change_img(v_file_path_name, self.ops_path_dir,
                                                              "<img draggable=\"false\" src=\"../PW_add_cont", "/>")
                        if n_changes > 0:
                            msg = " ".join([change_str, v_file, str(n_changes),
                                            "change <img draggable='false' src='../PW_add_cont in ex_ files  ..."])
                            if self.VERBOSE:
                                self.manage_info(msg, self.DISPLAY_AND_LOG)
                            else:
                                self.manage_info(msg, self.LOG_ONLY)
                        if v_return != "":
                            self.manage_info((v_return, self.DISPLAY_AND_LOG))
                        tot_changes += n_changes
                        n_text_changes += n_changes

                        # CHANGE #25c
                        # ===================
                        # delete <div> in button onclick
                        change_str = "   -> #" + str(change_no) + "p: "
                        v_return, n_changes = self.delete_balise_between_mark(v_file_path_name, "<button onclick",
                                                                              "</button>", "div")
                        if n_changes > 0:
                            msg = " ".join([change_str, v_file, str(n_changes), "change for button onclick in ex_ files ..."])
                            if self.VERBOSE:
                                self.manage_info(msg, self.DISPLAY_AND_LOG)
                            else:
                                self.manage_info(msg, self.LOG_ONLY)
                        if v_return != "":
                            self.manage_info((v_return, self.DISPLAY_AND_LOG))
                        tot_changes += n_changes
                        n_text_changes += n_changes

                        # CHANGE #25d
                        # ===================
                        # delete <div> in button onclick
                        change_str = "   -> #" + str(change_no) + "q: "
                        v_return, n_changes = self.delete_balise_between_mark(v_file_path_name,
                                                                              "button type=\"button\" onclick",
                                                                              "</button>", "div")
                        if n_changes > 0:
                            msg = " ".join([change_str, v_file, str(n_changes), "change for button onclick in ex_ files ..."])
                            if self.VERBOSE:
                                self.manage_info(msg, self.DISPLAY_AND_LOG)
                            else:
                                self.manage_info(msg, self.LOG_ONLY)
                        if v_return != "":
                            self.manage_info((v_return, self.DISPLAY_AND_LOG))
                        tot_changes += n_changes
                        n_text_changes += n_changes

        # CHANGE #26
        # ===================
        # modify the id's in content.opf if it begin with a number, insert a x at the begin of the id

        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        old_path_file_name = "".join([self.content_path_file_name, ".old"])
        new_path_file_name = self.content_path_file_name
        v_return = self.rename_file(new_path_file_name, old_path_file_name)
        n_changes = 0

        with open(old_path_file_name, "r", encoding="utf-8") as oldFile:
            with open(new_path_file_name, "w", encoding="utf-8") as newFile:
                html = oldFile.readlines()
                new_ligne = ""
                for ligne in html:
                    if "image" in ligne:
                        ct = ligne.split(" ")
                        for item in ct:
                            if "id=" in item:
                                a = item.split("=\"")
                                if a[1][0].isnumeric():
                                    item = "".join([a[0], "=\"", "x", a[1][0:]])
                            new_ligne += "".join([item, " "])
                            n_changes += 1
                    else:
                        new_ligne = ligne
                    newFile.write(new_ligne)
                    new_ligne = ""
        if n_changes > 0:
            msg = " ".join([change_str, v_file, str(n_changes), "modify the id's in content.opf"])
            self.manage_info(msg, self.LOG_ONLY)
        n_content_changes += n_changes
        tot_changes += n_changes
        os.remove(old_path_file_name)

        # QUALITY IMPROVE #27
        # ===================
        # in content.opf update media-type font if empty

        # content_opf_path_file_name = "".join([self.ops_path_dir, "content.opf"])
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        manifest_found = False
        with open(self.content_path_file_name, "r", encoding="utf-8") as opf_file_readable:
            opf_data = opf_file_readable.readlines()
            opf_file_readable.close()
        with open(self.content_path_file_name, "w", encoding="utf-8") as opf_file_writable:
            for l in opf_data:
                l_new = l
                if "</manifest>" in l:
                    manifest_found = False

                if manifest_found:
                    if "id=\"font" in l and "media-type=\"\"" in l:
                        l_new = l.replace("media-type=\"\"", "media-type=\"application/x-font-truetype\"")
                        n_changes += 1

                if "<manifest" in l:
                    manifest_found = True

                opf_file_writable.write(l_new)
            opf_file_writable.close()
        if n_changes > 0:
            msg = " ".join([change_str, v_file, str(n_changes), "in content.opf update media-type font if empty"])
            self.manage_info(msg, self.LOG_ONLY)
        n_content_changes += n_changes
        tot_changes += n_changes

        # QUALITY IMPROVE #28
        # ===================
        # in content.opf update media-type ncx if empty

        # content_opf_path_file_name = "".join([self.ops_path_dir, "content.opf"])
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        manifest_found = False
        with open(self.content_path_file_name, "r", encoding="utf-8") as opf_file_readable:
            opf_data = opf_file_readable.readlines()
            opf_file_readable.close()
        with open(self.content_path_file_name, "w", encoding="utf-8") as opf_file_writable:
            for l in opf_data:
                l_new = l
                if "</manifest>" in l:
                    manifest_found = False

                if manifest_found:
                    if "id=\"ncx" in l and "media-type=\"\"" in l:
                        l_new = l.replace("media-type=\"\"", "media-type=\"application/x-dtbncx+xml\"")
                        n_changes += 1

                if "<manifest" in l:
                    manifest_found = True

                opf_file_writable.write(l_new)
            opf_file_writable.close()

        if n_changes > 0:
            msg = " ".join([change_str, v_file, str(n_changes), "in content.opf update media-type "])
            self.manage_info(msg, self.LOG_ONLY)
        n_content_changes += n_changes
        tot_changes += n_changes

        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        file_list = os.listdir(self.text_path_dir)
        for f in file_list:
            v_file_path_name = "".join([self.text_path_dir, f])

            # QUALITY IMPROVE #29a
            # ===================
            # update mathml in content.opf <manifest>
            v_return, n_changes = self.update_mathml_in_manifest(v_file_path_name)
            if n_changes > 0:
                msg = " ".join([change_str, v_file, str(n_changes), "content mathml properties added"])
                self.manage_info(msg, self.LOG_ONLY)
            if v_return != "":
                self.manage_info((v_return, self.DISPLAY_AND_LOG))
            tot_changes += n_changes
            n_content_changes += n_changes

            # QUALITY IMPROVE #29b
            # ===================
            # update scripted in content.opf <manifest>
            if f != "nav.xhtml":
                v_return, n_changes = self.update_scripted_in_manifest(v_file_path_name)
                if n_changes > 0:
                    msg = " ".join([change_str, v_file, str(n_changes), "content scripted properties added"])
                    self.manage_info(msg, self.LOG_ONLY)
                if v_return != "":
                    self.manage_info((v_return, self.DISPLAY_AND_LOG))
                tot_changes += n_changes
                n_content_changes += n_changes

        # QUALITY IMPROVE #30
        # ===================
        # delete lines with PW-ad_cont in content.opf
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        v_return, n_changes = self.delete_line_with_PW_add_cont_in_opf(self.content_path_file_name)
        if n_changes > 0:
            msg = " ".join([change_str, v_file, str(n_changes), "content line with PW_ad_cont deleted"])
            self.manage_info(msg, self.DISPLAY_AND_LOG)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        tot_changes += n_changes
        n_content_changes += n_changes

        # QUALITY IMPROVE #31
        # ===================
        # replace position:absolute; with position:relative:
        file_name = "".join([])
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        v_return, n_changes = self.replace_asolute_with_relative_in_exercices_css(self.style_path_name)
        if n_changes > 0:
            msg = " ".join([change_str, v_file, str(n_changes), "replace absolute ref with relative"])
            self.manage_info(msg, self.DISPLAY_AND_LOG)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        tot_changes += n_changes
        n_styles_changes += n_changes

        # QUALITY IMPROVE #32
        # ===================
        # replace position:absolute; with position:relative:
        file_name = "".join([])
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        v_return, n_changes = self.delete_exercises0001_css_and_update_content_opf(self.style_path_name, self.content_path_file_name)
        if n_changes > 0:
            msg = " ".join([change_str, v_file, str(n_changes), "content line with PW_ad_cont deleted"])
            self.manage_info(msg, self.DISPLAY_AND_LOG)
        if v_return != "":
            self.manage_info((v_return, self.DISPLAY_AND_LOG))
        tot_changes += n_changes
        n_styles_changes += n_changes

        # before leaving make the xml files beautiful
        # ===========================================
        # prettifying html files

        # change_no += 1
        # change_str = "   #" + str(change_no) + ": "
        # msg = "... prettifying html files"
        # self.manage_info(msg, self.DISPLAY_AND_LOG)
        # n_changes = 0
        # for (v_path, v_dirs, v_files) in walk(self.text_path_dir):
        #     for v_file in v_files:
        #         v_extension = os.path.splitext(v_file)[1]
        #         if (v_extension == ".xhtml" or v_extension == ".html") and not "cover" in v_file:
        #             old_path_file_name = "".join([v_path, v_file, ".old"])
        #             new_path_file_name = "".join([v_path, v_file])
        #             v_return = self.rename_file(new_path_file_name, old_path_file_name)
        #             with open(old_path_file_name, "r", encoding="utf-8") as oldFile:
        #                 org_xhtml = oldFile.readlines()
        #
        #             pretty_xhtml = y.xml_formatter(org_xhtml)   #prettify the html
        #
        #             with open(new_path_file_name, "w", encoding="utf-8") as newFile:
        #                 newFile.writelines(pretty_xhtml)
        #
        #             n_changes += 1
        #             os.remove(old_path_file_name)
        #             tot_changes += n_changes
        #             n_text_changes += n_changes

        # CHANGE #34
        # ===================
        # generate TOC
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        self.generate_nav(self.text_path_dir, self.ops_path_dir, self.TOC_DEEP)
        #
        change_no += 1
        change_str = "   #" + str(change_no) + ": "
        self.generate_toc(self.text_path_dir, self.ops_path_dir, self.TOC_DEEP)

        # FINAL TASKS
        # ===================
        # creating the zipped epub file
        msg = "... creating the final zipped epub file"
        self.manage_info(msg, self.DISPLAY_AND_LOG)
        self.zip_epub(self.temp_path_dir, self.out_path_file_name)

        if self.WITH_ZIP:
            # create also the zip file
            self.zip_epub(self.temp_path_dir, self.out_path_file_name.replace(".epub", ".zip"))

        if self.WITH_DIR:
            # and also the directory with all the epub files
            out_dir_name = self.out_path_file_name.replace(".epub", "")

            # if exist delete the directory
            if os.path.exists(out_dir_name):
                shutil.rmtree(out_dir_name, ignore_errors=True)
            # create the new dir
            shutil.copytree(self.temp_path_dir, out_dir_name)
            os.chdir(self.cwd)

        os.chdir(self.cwd)

        # info that all its finished and deleting temporary files and directories
        self.manage_info("... putzing", self.DISPLAY_AND_LOG)
        # remove temporary files and directories
        if os.path.exists(self.temp_path_dir):
            v_return = self.empty_dir(self.temp_path_dir)
            if v_return != "":
                v_msg = "".join([self.log_path_file_name, v_return])
                self.write_in_logfile(v_msg)
            f_msg = "function new_job, final tasks : remove temp dir"
            try:
                os.rmdir(self.temp_path_dir)
            except:
                try:
                    time.sleep(self.ERROR_WAIT_TIME)
                    self.second_try += 1
                    self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                    self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                    os.rmdir(self.temp_path_dir)
                except:
                    self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)

        self.manage_info("job done", self.DISPLAY_ONLY)

        self.manage_info("-------------------------------------------------------", self.DISPLAY_AND_LOG, self.COLOR_BLUE)

        if n_text_changes > 0:  # 4
            msg = " ".join([str(n_text_changes), "modified text pages   n_text_changes"])
            self.manage_info(msg, self.DISPLAY_AND_LOG, self.COLOR_BLUE)

        if n_images_changes > 0:  # 1
            msg = " ".join([str(n_images_changes), "modified images   n_images_changes"])
            self.manage_info(msg, self.DISPLAY_AND_LOG, self.COLOR_BLUE)

        if n_styles_changes > 0:  # 12
            msg = " ".join([str(n_styles_changes), "modified styles   n_styles_changes"])
            self.manage_info(msg, self.DISPLAY_AND_LOG, self.COLOR_BLUE)

        if n_content_changes > 0:  # 7
            msg = " ".join([str(n_content_changes), "content.opf changes   n_content_changes"])
            self.manage_info(msg, self.DISPLAY_AND_LOG, self.COLOR_BLUE)

        if n_nav_toc_changes > 0:  # 9 #10
            msg = " ".join([str(n_nav_toc_changes), "nav and toc changes   n_nav_toc_changes"])
            self.manage_info(msg, self.DISPLAY_AND_LOG, self.COLOR_BLUE)

        if n_pages_deleted > 0:  # 3
            msg = " ".join([str(n_pages_deleted), "empty xhtml pages removed   n_pages_deleted"])
            self.manage_info(msg, self.DISPLAY_AND_LOG, self.COLOR_BLUE)

        self.t_stop = time.time()
        elapsed_time = self.t_stop - self.t_start
        self.manage_info("-------------------------------------------------------", self.DISPLAY_AND_LOG, self.COLOR_BLUE)
        self.manage_info(" ".join([str(tot_changes), "changes made for this ebbok"]), self.DISPLAY_AND_LOG, self.COLOR_BLUE)
        self.manage_info("-------------------------------------------------------", self.DISPLAY_AND_LOG)
        self.manage_info("".join(["Job OK, task completed in ", str("{:.2f}".format(elapsed_time)), " [s]"]), self.DISPLAY_AND_LOG, self.COLOR_GREEN)
        # if not self.program_in_test and not self.dir_job_status:
        #     self.manage_info(" ;-)   thanks for using this amazing program developed by josmet for the FET", self.DISPLAY_AND_LOG, self.COLOR_GREEN)
        self.manage_info("Select a new task", self.DISPLAY_AND_LOG, self.COLOR_RED)
        self.manage_info("-------------------------------------------------------", self.DISPLAY_AND_LOG)

    # 333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333

    # fonction qui retourne le nom du répertoire OEBPS ou OPS selon la VERSION du fichier ePub
    def get_ops_dir(self, epub_path):
        """ retourne le nom du répertoire OPS ou OEBPS selon la VERSION et le logiciel utilisé
            input : epub_path : chemin du répertoire dans lequel le fichier epub est dezipe
            return : the name of the OPS directory (OPS or OEBPS)
        """
        ok = False
        oe_path = ""
        if os.path.exists(epub_path + "/OEBPS"):
            oe_path = "OEBPS/"
            ok = True
        elif os.path.exists(epub_path + "/OPS"):
            oe_path = "OPS/"
            ok = True
        return ok, oe_path

    def convert_cmyk_2_rgb(self, path_image_dir):
        """
        """
        n_changes = 0
        for f in listdir(path_image_dir):
            ff = "".join([path_image_dir, f])
            image = Image.open(ff)
            if image.mode == 'CMYK':
                image_new = image.convert('RGB')
                image_new.save(ff)
                n_changes += 1
        return n_changes

    def resize_img(self, path_image_dir, img_size_max):
        """
            this function reduce the image size to a max value
            input :
                path_image_dir : the path of the image directory
                img_size_max : the max size of the images
            return : nothing
        """
        n_resize = 0
        for (v_path, v_dirs, v_files) in walk(path_image_dir):
            for v_file in v_files:
                file_name, file_extension = os.path.splitext(v_file)
                img_name = path_image_dir + "/" + file_name + file_extension
                f_msg = "Resize images"
                try:
                    with Image.open(path_image_dir + v_file) as vImage:
                        x, y = vImage.size
                        biger_size = max(x, y)
                        if biger_size > img_size_max:
                            factor = img_size_max / biger_size
                            x1 = int(x * factor)
                            y1 = int(y * factor)
                            new_size = x1, y1
                            resized_image = vImage.resize(new_size, Image.ANTIALIAS)
                            resized_image.save(img_name)
                            n_resize += 1
                except:
                    try:
                        time.sleep(self.ERROR_WAIT_TIME)
                        self.second_try += 1
                        self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                        self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                        with Image.open(path_image_dir + v_file) as vImage:
                            x, y = vImage.size
                            biger_size = max(x, y)
                            if biger_size > img_size_max:
                                factor = img_size_max / biger_size
                                x1 = int(x * factor)
                                y1 = int(y * factor)
                                new_size = x1, y1
                                resized_image = vImage.resize(new_size, Image.ANTIALIAS)
                                resized_image.save(img_name)
                                n_resize += 1
                    except:
                        self.manage_error(" ".join(["Error in", f_msg]), self.error_msg(sys.exc_info()), 3)
        return n_resize

    # this function remove all empty xhtml pages
    def del_empty_pages(self, ops_path_dir):
        """
            this function remove all empty or temporary xhtml pages
            input :
                ops_path_dir : the path of the OPS directory
            return : nothing
        """
        n_delete_pages = int()
        n_delete_pages = 0
        f = ""
        # remove temp xhtml pages
        for (v_path, v_dirs, v_files) in walk("".join([ops_path_dir, 'Text/'])):
            for v_file in v_files:
                file_path_name = "".join([v_path, v_file])
                file_name, file_extension = os.path.splitext(v_file)
                if "temp" in file_name and file_extension == ".xhtml":
                    n_delete_pages += 1
                    f_msg = "function del_empty_pages : remove temp file"
                    try:
                        # os.remove(file_path_name)
                        self.remove_file_and_update_opf(v_file, file_path_name)

                    except:
                        try:
                            time.sleep(self.ERROR_WAIT_TIME)
                            self.second_try += 1
                            self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                            self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                            self.remove_file_and_update_opf(v_file, file_path_name)
                            # os.remove(file_path_name)
                        except:
                            self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)
                            if self.DEBUG:
                                print("".join([f_msg, v_file]), 3)
        # remove empty pages with the name beginig with th_ or ex_
        for (v_path, v_dirs, v_files) in walk("".join([ops_path_dir, 'Text/'])):
            for v_file in v_files:
                file_path_name = "".join([v_path, v_file])
                file_name, file_extension = os.path.splitext(v_file)
                if file_name[:3] in ["th_", "ex_"]:
                    body_lines = 99999
                    body_len = 99999
                    f_msg = "function del_empty_pages : examine if empty pages"
                    try:
                        f = open(v_path + v_file, 'r', encoding='utf-8')
                    except:
                        try:
                            time.sleep(self.ERROR_WAIT_TIME)
                            self.second_try += 1
                            self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                            self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                            f = open(v_path + v_file, 'r', encoding='utf-8')
                        except:
                            self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)
                            if self.DEBUG:
                                print("".join([f_msg, v_file]), 3)

                    else:
                        data = f.read()
                        soup = BeautifulSoup(data, 'html.parser')
                        body_str = str(soup.body).replace(" ", "")
                        body_lines = len(body_str.split("\n"))
                        body_len = len(body_str)
                    finally:
                        try:
                            f.close()
                        except:
                            msg = "".join(
                                [f_msg, "\nThe file ", file_path_name, " is not opened so close() is not possible"])
                            self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)

                    if body_lines <= 6 and body_len <= 50:
                        if self.DEBUG:
                            print("".join(
                            ["REMOVED_EMPTY_FILE : ", v_file, " body lines : ", str(body_lines), " body char : ",
                             str(body_len)]), 3)
                        n_delete_pages += 1
                        f_msg = "function del_empty_pages : remove empty .xhtml pages"
                        try:
                            self.remove_file_and_update_opf(v_file, file_path_name)
                        except:
                            try:
                                time.sleep(self.ERROR_WAIT_TIME)
                                self.second_try += 1
                                self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                                self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                                self.remove_file_and_update_opf(v_file, file_path_name)
                            except:
                                self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)
                                if self.DEBUG:
                                    print("".join([f_msg, v_file]), 3)

        return n_delete_pages

    def remove_file_and_update_opf(self, v_file_name, v_file_path_name):
        """
            this function delete the file and adapt the content.ops file
            input : v_file_name : name of the file in content.ops
                    v_file_path_name : path and name of the file to be deleted
            output : nothing
        """
        # delete file
        os.remove(v_file_path_name)
        # update content.opf
        old_path_file_name = "".join([self.content_path_file_name, ".old"])
        new_path_file_name = self.content_path_file_name
        v_return = self.rename_file(new_path_file_name, old_path_file_name)
        with open(old_path_file_name, "r", encoding="utf-8") as oldFile:
            with open(new_path_file_name, "w", encoding="utf-8") as newFile:
                for l in oldFile:
                    if v_file_name not in l:
                        newFile.write(l)
        os.remove(old_path_file_name)

    def update_cover(self, v_path_file):
        """
            this function replace the contents of the cover page of a epub with a new one
            input : v_path_file : path and file name
            output : nothing
        """
        cover_name = "name_undefined"
        x_cover = open(v_path_file, "w", encoding="utf-8")
        x_cover.write("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>\n")
        x_cover.write("<!DOCTYPE html>\n")
        x_cover.write("<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\">\n")
        x_cover.write("<head>\n")
        x_cover.write("<title>Cover</title>\n")
        x_cover.write("</head>\n")
        x_cover.write("<body>\n")
        x_cover.write("<div style=\"text-align: center; padding: 0pt; margin: 0pt;\">\n")
        x_cover.write(
            "<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"100%\" preserveAspectRatio=\"xMidYMid meet\" version=\"1.1\" viewBox=\"0 0 705 939\" width=\"100%\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n")

        img_file = ""
        only_files = [f for f in listdir(self.image_path_dir) if isfile(join(self.image_path_dir, f))]
        for img_file in only_files:
            if "cover" in img_file:
                cover_name = img_file

        x_cover.write("".join(["<image width=\"705\" height=\"939\" xlink:href=\"../Images/", cover_name, "\"/>\n"]))
        x_cover.write("</svg>\n")
        x_cover.write("</div>\n")
        x_cover.write("</body>\n")
        x_cover.write("</html>\n")
        return 1

    def copy_images(self, pw_path_dir, image_path_dir):
        """
            this function copy images from the PW_add_cont to the Images directory
            in the Publiwide ePub the images are in the PW_add_cont directory and they must be in the Images directory
            input :
                pw_path_dir : path and dir name of the PW directory
                image_path_dir : path and dir name of the Images directory
            output : nothing
        """
        n_copy = 0
        for (v_path, v_dirs, v_files) in walk(pw_path_dir):
            for v_file in v_files:
                file_name, file_extension = os.path.splitext(v_file)
                if file_extension == ".jpg" or file_extension == ".png":
                    sce_file = "".join([v_path, "/", v_file]).replace("\\", "/")
                    dst_file = "".join([image_path_dir, v_file])
                    f_msg = "function copy_images"
                    try:
                        copyfile(sce_file, dst_file)
                    except:
                        try:
                            time.sleep(self.ERROR_WAIT_TIME)
                            self.second_try += 1
                            self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                            self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                            copyfile(sce_file, dst_file)
                        except:
                            self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)
                            if self.DEBUG:
                                print("".join([f_msg, v_file]), 3)
                    n_copy += 1
        return n_copy

    def update_mathml_in_manifest(self, v_path_file_name):
        """
            this function add the mathml declaration in content.opf <manifest> if ncessary
            input :
                v_path_file_name : path and name of the file to modify
        return : if ok : return an empty string
               : else : return a message
        """
        n_changes = 0
        v_return = ""
        with open(v_path_file_name, "r", encoding="utf-8") as x_file:
            xml_data = x_file.readlines()
            x_file.close()
        mathml_found = False
        for l in xml_data:
            if "mathml" in l.lower():
                current_file_name = os.path.basename(v_path_file_name)
                mathml_found = True

        if mathml_found:
            with open(self.content_path_file_name, "r", encoding="utf-8") as content_file:
                content_data = content_file.readlines()
                content_file.close()

            with open(self.content_path_file_name, "w", encoding="utf-8") as content_file:
                manifest_found = False
                propertie_added = False

                for l in content_data:
                    new_line = l
                    if "</manifest>" in l:
                        manifest_found = False

                    if manifest_found and not propertie_added:
                        if (current_file_name in l) and not ("properties" in l.lower()):
                            old_str = "/>"
                            new_str = " properties=\"mathml\" />"
                            new_line = l.replace(old_str, new_str)
                            propertie_added = True
                            n_changes += 1
                        elif current_file_name in l and "properties" in l.lower() and "mathml" not in l.lower():
                            old_str = "\"/>"
                            new_str = " mathml\"/>"
                            new_line = l.replace(old_str, new_str)
                            propertie_added = True
                            n_changes += 1
                            # print("OLD_LINE :", l)
                            # print ("OLD_STR :", old_str)
                            # print("NEW_STR :", new_str)
                            # print("NEW_LINE :", new_line)
                            # print()

                    if "<manifest>" in l:
                        manifest_found = True

                    content_file.write(new_line)

                content_file.close()

        if v_return != "":
            v_return = "CHANGE_TXT : " + v_return
        return v_return, n_changes

    def update_scripted_in_manifest(self, v_path_file_name):
        """
            this function add the mathml declaration in content.opf <manifest> if ncessary
            input :
                v_path_file_name : path and name of the file to modify
        return : if ok : return an empty string
               : else : return a message
        """
        n_changes = 0
        v_return = ""
        with open(v_path_file_name, "r", encoding="utf-8") as x_file:
            xml_data = x_file.readlines()
            x_file.close()

        script_found = False

        current_file_name = os.path.basename(v_path_file_name)
        for l in xml_data:
            if "javascript" in l.lower():
                script_found = True

        if script_found:
            with open(self.content_path_file_name, "r", encoding="utf-8") as content_file:
                content_data = content_file.readlines()
                content_file.close()

            with open(self.content_path_file_name, "w", encoding="utf-8") as content_file:
                manifest_found = False
                propertie_added = False

                for l in content_data:
                    new_line = l
                    if "</manifest>" in l:
                        manifest_found = False

                    if manifest_found and not propertie_added:
                        if current_file_name in l and "properties" not in l.lower():
                            old_str = "/>"
                            new_str = " properties=\"scripted\" />"
                            new_line = l.replace(old_str, new_str)
                            propertie_added = True
                            n_changes += 1
                        elif current_file_name in l and "properties" in l.lower() and "scripted" not in l.lower():
                            if "\"/>" in l:
                                old_str = "\"/>"
                            elif "\" />" in l:
                                old_str = "\" />"
                            new_str = " scripted\"/>"
                            # new_line = l.replace("\" ","").replace(old_str, new_str)
                            new_line = l.replace(old_str, new_str)
                            propertie_added = True
                            n_changes += 1

                    if "<manifest>" in l:
                        manifest_found = True

                    content_file.write(new_line)

                content_file.close()

        if v_return != "":
            v_return = "CHANGE_TXT : " + v_return
        return v_return, n_changes

    def change_txt(self, v_path_file_name, old_txt, new_txt):
        """
            this function replace a string with another one in a epub html file
            input :
                v_path_file_name : path and name of the file to modify
                old_txt : text to be replaced with the new one
                new_txt : text to replace the old one
        return : if ok : return an empty string
               : else : return a message
        """
        n_changes = 0
        if os.path.isfile(v_path_file_name):
            old_path_file_name = "".join([v_path_file_name, ".old"])
            v_return = self.rename_file(v_path_file_name, old_path_file_name)
            with open(old_path_file_name, "r", encoding="utf-8") as oldFile:
                with open(v_path_file_name, "w", encoding="utf-8") as newFile:
                    for line in iter(oldFile):
                        if old_txt in line:
                            n_changes += 1
                        newFile.write(line.replace(old_txt, new_txt))
            os.remove(old_path_file_name)
            if v_return != "":
                v_return = "CHANGE_TXT : " + v_return
            return v_return, n_changes
        else:
            return "WARNING:file " + os.path.basename(v_path_file_name) + " n'existe pas dans ce epub", 0

    # mise à jour de la page content.opf pour des fichiers importés
    def add_line(self, v_path_file_name, v_tag, new_txt):
        """
            this function insert a new line in a epub html file
            input :
                v_path_file_name : path and name of the file to modify
                v_tag : tag where the new line must be inserted
                new_txt : text to be inserted
        return : if ok : return an empty string
               : else : return a message
        """
        n_changes = 0
        tag_found = False
        old_path_file_name = "".join([v_path_file_name, ".old"])
        v_return = self.rename_file(v_path_file_name, old_path_file_name)
        with open(old_path_file_name, "r", encoding="utf-8") as oldFile:
            with open(v_path_file_name, "w", encoding="utf-8") as newFile:
                data = oldFile.readlines()
                for l in data:
                    if "".join(["</", v_tag, ">"]) in l:
                        newFile.write(new_txt)
                        n_changes += 1
                        tag_found = True
                    newFile.write(l)
        os.remove(old_path_file_name)
        if tag_found:
            v_return = ""
        else:
            v_return = "".join(["WARNING : tag ", v_tag, " not found in ", os.path.basename(v_path_file_name)])
        return v_return, n_changes

    # mise à jour de la page content.opf pour des fichiers importés
    def del_line_in_content_opf(self, v_path_file_name, del_txt):
        """
            this function delete a line in a epub html file
            input :
                v_path_file_name : path and name of the file to modify
                v_tag : tag where the new line must be inserted
                new_txt : text to be inserted
        return : if ok : return an empty string
               : else : return a message
        """
        n_changes = 0
        tag_found = False
        old_path_file_name = "".join([v_path_file_name, ".old"])
        v_return = self.rename_file(v_path_file_name, old_path_file_name)
        with open(old_path_file_name, "r", encoding="utf-8") as oldFile:
            with open(v_path_file_name, "w", encoding="utf-8") as newFile:
                data = oldFile.readlines()
                for l in data:
                    if del_txt not in l:
                        newFile.write(l)
                    else:
                        tag_found = True
        os.remove(old_path_file_name)
        if tag_found:
            v_return = ""
        else:
            v_return = "".join(["WARNING : text ", del_txt, " not found in ", os.path.basename(v_path_file_name)])
        return v_return, 1

    # mise à jour de la page content.opf pour des fichiers importés
    def get_id_value(self, v_path_file_name, v_tag):
        """
            this function replace the content of a tag value in a epub html file
            input :
                v_path_file_name : path and name of the file to modify
                v_tag : tag where the new line must be inserted
        return : id value
        """
        f_msg = "get_id_value"
        v_title = ""
        v_file = ""
        try:
            with open(v_path_file_name, "r", encoding="utf-8") as v_file:
                data = v_file.read()
                soup = BeautifulSoup(data, 'html.parser')
                for rows in soup.find([v_tag]):
                    v_title = rows
        except:
            self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)
            if self.DEBUG:
                print("".join([f_msg, v_file]), 3)
        return v_title

    # modification pour les formules à mettre en évidence
    def change_formula(self, v_path_file_name, txt_2_find_start, txt_2_find_stop, new_txt_start, new_txt_stop):
        """
            this function replace the CSS style for formulas but let the formula itself inchanged
            input :
                v_path : path of the file
                v_files : name of the file
                txt_2_find_start : begin of the string to be replaced
                txt_2_find_stop : end of the string to be replaced
                new_txt_start : text to be inserted before the formula
                new_txt_stop : text to be inserted after the formula
            return : if ok : return an empty string
                   : else : return a message
        """
        n_changes = 0
        old_path_file_name = "".join([v_path_file_name, ".old"])
        v_return = self.rename_file(v_path_file_name, old_path_file_name)
        with open(old_path_file_name, "r", encoding="utf-8") as oldFile:
            with open(v_path_file_name, "w", encoding="utf-8") as newFile:
                # parcourir toutes les lignes
                for line in iter(oldFile):
                    i = 0
                    if txt_2_find_start in line and txt_2_find_stop in line:
                        # txt de debut trouve
                        one_more = True
                        pos_next = 0
                        new_line = ""
                        i = 0
                        while one_more:
                            # trouver index debut et fin du string à modifier
                            pos_start = line.index(txt_2_find_start, pos_next)
                            pos_stop = line.index(txt_2_find_stop, pos_start) + len(txt_2_find_stop)
                            # trouver le texte à modifier
                            txt2mask = line[pos_start: pos_stop]
                            pos_txt_formula_start = int(txt2mask.index("<span>"))
                            pos_txt_formula_stop = int(txt2mask.index("</span>") + len("</span>"))
                            txt_formula = txt2mask[
                                          pos_txt_formula_start + len("<span>"): pos_txt_formula_stop - len("</span>")]
                            # construire le nouveau texte à insérer dans le fichier
                            new_txt = new_txt_start + txt_formula + new_txt_stop
                            if i == 0:
                                new_line = line.replace(txt2mask, new_txt)
                            else:
                                new_line = new_line.replace(txt2mask, new_txt)
                            pos_next = pos_stop
                            i += 1
                            if txt_2_find_start not in line[pos_stop:]:
                                one_more = False
                        newFile.write(new_line)
                    else:
                        # la ligne est ok on l'enregistre tel quel
                        newFile.write(line)
                    n_changes += i
        # effacer l'ancien fichier
        os.remove(old_path_file_name)
        if v_return != "":
            v_return = "change_formula " + v_return
        return v_return, n_changes

    def rename_file(self, sce_file_path_name, dst_file_path_name):
        """
            this function rename a file from sce_file_path_name to dst_file_path_name
            input :
                sce_file_path_name : file to be renamed
                dst_file_path_name : new name to be used
            return : if ok : return an empty string
                   : else : return a message
        """
        v_return = ""
        # verify if source file name exist really
        if os.path.exists(sce_file_path_name):
            f_msg = "function rename_file"
            try:
                while os.access(sce_file_path_name, os.W_OK) == 0:
                    time.sleep(self.ERROR_WAIT_TIME)
                os.rename(sce_file_path_name, dst_file_path_name)
            except:
                try:
                    time.sleep(self.ERROR_WAIT_TIME)
                    self.second_try += 1
                    self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                    self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                    while os.access(sce_file_path_name, os.W_OK) == 0:
                        time.sleep(self.ERROR_WAIT_TIME)
                    os.rename(sce_file_path_name, dst_file_path_name)
                except:
                    self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)
                    if self.DEBUG:
                        print("".join([f_msg, sce_file_path_name, dst_file_path_name]), 3)
        return v_return

    # mise en commentaire de textes
    def comment_out_and_insert(self, v_path_file_name, txt_2_find_start, txt_2_find_stop, txt2add):

        """
            this function put in comment out part of text and insert a new one
            input :
                v_path : path of the file
                v_files : name of the file
                txt_2_find_start : begin of the string to be replaced
                txt_2_find_stop : end of the string to be replaced
                txt2add : text to be inserted after the commented text
            return : if ok : return an empty string
                   : else : return a message
        """
        n_changes = 0
        new_line = ""

        old_path_file_name = "".join([v_path_file_name, ".old"])
        v_return = self.rename_file(v_path_file_name, old_path_file_name)
        with open(old_path_file_name, "r", encoding="utf-8") as oldFile:

            with open(v_path_file_name, "w", encoding="utf-8") as newFile:
                txt2mask = ""
                for line in iter(oldFile):
                    if txt_2_find_start in line and txt_2_find_stop in line:
                        for infoTxt2FindStart in re.finditer(txt_2_find_start, line):
                            pos_start = infoTxt2FindStart.start()
                            pos_stop = line.index(txt_2_find_stop, pos_start) + len(txt_2_find_stop) - 1
                            txt2mask = line[pos_start: pos_stop]
                            # new_txt = "<!--" + txt2mask + "-->" + txt2add
                            new_txt = txt2add
                            new_line = line[:pos_start] + new_txt + line[pos_stop:]
                            # line = new_line
                        newFile.write(new_line)
                        n_changes += 1
                    else:
                        newFile.write(line)

        os.remove(old_path_file_name)
        if v_return != "":
            v_return = "comment_out_th " + v_return
        return v_return, n_changes

    # modification pour les images des pages de théorie
    def remove_txt(self, v_path_file_name, txt_2_find_start, txt_2_find_stop):
        """
            this function remove a text in a html epub file
            input :
                v_path : path of the file
                v_files : name of the file
                txt_2_find_start : begin of the string to be replaced
                txt_2_find_stop : end of the string to be replaced
            return : if ok : return an empty string
                   : else : return a message
        """
        n_changes = 0
        old_path_file_name = "".join([v_path_file_name, ".old"])
        v_return = self.rename_file(v_path_file_name, old_path_file_name)
        with open(old_path_file_name, "r", encoding="utf-8") as oldFile:
            with open(v_path_file_name, "w", encoding="utf-8") as newFile:
                txt2mask = ""
                for line in iter(oldFile):
                    if txt_2_find_start in line:
                        for infoTxt2FindStart in re.finditer(txt_2_find_start, line):
                            pos_start = infoTxt2FindStart.start()
                            pos_stop = line.index(txt_2_find_stop, pos_start) + len(txt_2_find_stop)
                            new_line = line[:pos_start] + line[pos_stop:]
                            newFile.write(new_line)
                            n_changes += 1
                    else:
                        newFile.write(line)
        os.remove(old_path_file_name)
        if v_return != "":
            v_return = "remove_txt_th " + v_return
        return v_return, n_changes

    # modification pour les images des exercices
    def delete_balise_between_mark(self, v_path_file_name, txt_2_find_start, txt_2_find_stop, bal2delete):
        """
            this function remove a text in a html epub file
            input :
                v_path : path of the file
                v_files : name of the file
                txt_2_find_start : begin of the string to be replaced
                txt_2_find_stop : end of the string to be replaced
            return : if ok : return an empty string
                   : else : return a message
        """
        bal_begin = "".join(["<", bal2delete, ">"])
        bal_end = "".join(["</", bal2delete, ">"])
        n_changes = 0
        line_nr = 0
        old_path_file_name = "".join([v_path_file_name, ".old"])
        v_return = self.rename_file(v_path_file_name, old_path_file_name)
        with open(old_path_file_name, "r", encoding="utf-8") as oldFile:
            with open(v_path_file_name, "w", encoding="utf-8") as newFile:
                txt2mask = ""
                new_line = ""
                for line in iter(oldFile):
                    line_nr += 1
                    if txt_2_find_start in line and txt_2_find_stop in line:
                        new_line = ""
                        pos_stop = 0
                        end_found = False
                        while not end_found:
                            pos_start = int(line.find(txt_2_find_start, pos_stop))
                            if pos_start != -1:
                                l_str = line[pos_stop: pos_start]
                                pos_stop = int(line.index(txt_2_find_stop, pos_start) + len(txt_2_find_stop))
                                txt2modify = line[pos_start:pos_stop]
                                txt2modify = txt2modify.replace(bal_begin, "")
                                txt2modify = txt2modify.replace(bal_end, "")
                                new_line = "".join([new_line, l_str, txt2modify])
                            else:
                                end_found = True
                                new_line = "".join([new_line, line[pos_stop:]])

                            n_changes += 1
                    else:
                        new_line = line
                    newFile.write(new_line)

        os.remove(old_path_file_name)
        if v_return != "":
            v_return = "remove_txt_th " + v_return
        return v_return, n_changes

    def zip_epub(self, temp_path_dir, zip_file_path_name):
        """
            this function integrate all the files in the final epub zipped file
            input :
                temp_path_dir : path of the root of the zip data
                zip_file_path_name : path and name of the zipped epub file
            return : nothing
        """
        f_msg = "function zip_epub : creating the final zip file"
        zip_file = ""
        try:
            zip_file = zipfile.ZipFile(zip_file_path_name, "w")
        except:
            try:
                time.sleep(self.ERROR_WAIT_TIME)
                self.second_try += 1
                self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                while os.access(zip_file_path_name, os.W_OK) == 0:
                    time.sleep(self.ERROR_WAIT_TIME)
                zip_file = zipfile.ZipFile(zip_file_path_name, "w")
            except:
                self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)
                if self.DEBUG:
                    print("".join([f_msg, zip_file_path_name]), 3)

        # first add the mimetype file
        mimetype_path_file_name = "".join([temp_path_dir, "mimetype"])
        zip_file.write(mimetype_path_file_name, "mimetype")

        # zip all files in the zip
        # os.chdir(self.temp_path_dir)
        os.chdir(temp_path_dir)
        for dir_name, subDirs, files in os.walk("."):  # temp_path_dir):
            # but not the PW_add_cont directory
            if "PW_add_cont" not in dir_name and dir_name != ".":
                f_msg = "function zip_epub : copying the directories in the final zip"
                if os.listdir(dir_name):  # directory is not empty
                    try:
                        zip_file.write(dir_name)
                    except:
                        try:
                            time.sleep(self.ERROR_WAIT_TIME)
                            self.second_try += 1
                            self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                            self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                            zip_file.write(dir_name)
                        except:
                            self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)
                            if self.DEBUG:
                                print("".join([f_msg, zip_file_path_name]), 3)

                    f_msg = "function zip_epub : copying the files in the final zip"
                    for file in files:
                        try:
                            if file != "mimetype":
                                while os.access(os.path.join(dir_name, file), os.W_OK) == 0:
                                    time.sleep(self.ERROR_WAIT_TIME)
                                zip_file.write(os.path.join(dir_name, file))

                        except:
                            try:
                                time.sleep(self.ERROR_WAIT_TIME)
                                self.second_try += 1
                                self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                                self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                                while os.access(os.path.join(dir_name, file), os.W_OK) == 0:
                                    time.sleep(self.ERROR_WAIT_TIME)
                                zip_file.write(os.path.join(dir_name, file))
                            except:
                                self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)
                                if self.DEBUG:
                                    print("".join([f_msg, zip_file_path_name]), 3)
        # fl =zip_file.infolist()
        # for f in fl:
        #     print(f)
        zip_file.close()
        os.chdir(self.cwd)

    def change_img(self, v_path_file_name, ops_path, txt_2_find_start, txt_2_find_stop):
        """
            this function replace text of images and correct the content of the content.opf file
            input :
                v_path : path of the file
                v_files : name of the file
                ops_path : OPS or OEBPS depending of the epub VERSION
                txt_2_find_start : begin of the string to be replaced
                txt_2_find_stop : end of the string to be replaced
            return : if ok : return an empty string
                   : else : return a message
        """
        org_name = v_path_file_name
        new_name = "".join([v_path_file_name, ".old"])
        v_return = self.rename_file(org_name, new_name)
        n_changes = 0
        new_opf_string = ""
        with open(new_name, "r", encoding="utf-8") as oldFile:
            with open(org_name, "w", encoding="utf-8") as newFile:
                # parcourir toutes les lignes
                content_list = list()
                img_list = list()
                previous_line = ""
                for line in iter(oldFile):
                    if txt_2_find_start in line:
                        # txt de debut trouve
                        i = 0
                        line_list = list()
                        mask_list = list()
                        for infoTxt2FindStart in re.finditer(txt_2_find_start, line):
                            i += 1
                            # trouver index debut et fin du string à modifier
                            pos_start = infoTxt2FindStart.start()
                            pos_stop = line.index(txt_2_find_stop, pos_start) + len(txt_2_find_stop)
                            # trouver le texte à modifier
                            txt2mask = line[pos_start: pos_stop]
                            txt_image = txt2mask[:len(txt2mask) - 3]
                            # recherche du début et de la fin du nom de l'image
                            img_name_start = txt_image.rfind("/") + 1
                            img_name_stop = txt_image.index(".", img_name_start) + 4
                            # trouver le nom de l'image
                            img_name = txt_image[img_name_start:img_name_stop]
                            img_name.strip()

                            # construire le nouveau path name de l'image
                            ok_img = False
                            if "button onclick" in line:
                                new_img_text = "<img src=\"../Images/" + img_name + "\" alt=\"image manquante\"/>"
                            else:
                                new_img_text = "<div class=\"imagecontainer w50\"><img src=\"../Images/" + img_name + "\" alt=\"image manquante\"/></div>"

                            # construire le nouveau texte à insérer dans le fichier
                            new_txt = "<!--" + txt2mask + "-->" + new_img_text
                            line_list.append(new_txt)
                            mask_list.append(txt2mask)
                            # enregistrer la nouvelle ligne dans le fichier content.opf
                            if ".jpg" in img_name:
                                new_opf_string = "    <item id=\"" + img_name + "\" href=\"Images/" + img_name + "\" media-type=\"image/jpeg\"/>"
                                n_changes += 1
                                ok_img = True
                            elif ".png" in img_name:
                                new_opf_string = "    <item id=\"" + img_name + "\" href=\"Images/" + img_name + "\" media-type=\"image/png\"/>"
                                ok_img = True
                                n_changes += 1

                            # ne traiter qu'une seule chaque image même si elle se retrouve plusieurs fois dans l'exercice
                            if ok_img:
                                if img_name not in img_list:
                                    img_list.append(img_name)
                                    content_list.append(new_opf_string)
                            n_changes += 1
                        i = 0
                        for txtChange in line_list:
                            txt_mask = mask_list[i]
                            line = line.replace(txt_mask, txtChange)
                            i += 1
                        newFile.write(line)
                    else:
                        # la ligne est ok on l'enregistre tel quel
                        newFile.write(line)
                    previous_line = line

        # mettre à jour le fichier content.opf
        if len(content_list) > 0:
            o_file = "content.opf"
            new_file_path_name = ops_path + o_file
            old_file_path_name = ops_path + "old_" + o_file
            v_return = self.rename_file(new_file_path_name, old_file_path_name)
            with open(old_file_path_name, "r", encoding="utf-8") as oldFile:
                r = oldFile.readlines()
                s = list()
                to_check = False
                for l in r:
                    if "<manifest>" in l:
                        to_check = True
                    if "</manifest>" in l:
                        to_check = False
                    if to_check:
                        s.append(l.strip())
            with open(old_file_path_name, "r", encoding="utf-8") as oldFile:
                with open(new_file_path_name, "w", encoding="utf-8") as newFile:
                    for line in iter(oldFile):
                        if "</manifest>" in line:
                            for opfString2add in content_list:
                                if not opfString2add.strip() in s:
                                    newFile.write(opfString2add + "\n")
                                    n_changes += 1
                            newFile.write(line)
                        else:
                            newFile.write(line)
            os.remove(old_file_path_name)

        # effacer l'ancien fichier
        os.remove(new_name)
        if v_return != "":
            v_return = "change_img " + v_return
        return v_return, n_changes

    # fonction qui efface tout le contenu d'un répertoire
    def empty_dir(self, x_path):
        """
            fonction qui efface tout le contenu d'un répertoire
            input : the path of the directoy to empty
            return : if ok : return an empty string
                   : else : return a message
        """
        v_return = ""
        v_file = ""
        for v_path, v_dirs, v_files in os.walk(x_path, topdown=False):
            for v_file in v_files:
                f_msg = "function empty_dir: erasing files in directory"
                try:
                    os.remove(os.path.join(v_path, v_file))
                except:
                    try:
                        time.sleep(self.ERROR_WAIT_TIME)
                        self.second_try += 1
                        self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                        self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                        os.remove(os.path.join(v_path, v_file))
                    except:
                        self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)
                        if self.DEBUG:
                            print("".join([f_msg, v_file]), 3)
            for vDir in v_dirs:

                f_msg = "empty_dir: erasing empty directory"
                try:
                    os.rmdir(os.path.join(v_path, vDir))
                except:
                    try:
                        time.sleep(self.ERROR_WAIT_TIME)
                        self.second_try += 1
                        self.manage_info(" ".join(["2nd try in", f_msg]), self.DISPLAY_AND_LOG)
                        self.manage_error(" ".join(["2nd try in", f_msg]), "", 1)
                        os.rmdir(os.path.join(v_path, vDir))
                    except:
                        self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 3)
                        if self.DEBUG:
                            print("".join([f_msg, v_file]), 3)
        return v_return

    def manage_info(self, v_msg, v_type=0, v_color=0):
        """
            this function display and/or record a message in the log file
            input : v_msg : message to display and to record in log file
                    v_type : 1 > display, 2 > display and log, 3 > log
                    if the global var self.DEBUG is true > the message is printed in the shell window
        """
        try:
            if v_type == 1:  # only on the display
                self.msg_list.insert(tk.END, v_msg)
                self.msg_list.see("end")
            elif v_type == 2:  # on the display and in the log file
                self.msg_list.insert(tk.END, v_msg)
                if v_color > 0:
                    if v_color == 1:
                        self.msg_list.itemconfig(tk.END, fg='red')
                    elif v_color == 2:
                        self.msg_list.itemconfig(tk.END, fg='blue')
                    elif v_color == 3:
                        self.msg_list.itemconfig(tk.END, fg='green')
                    elif v_color == 4:
                        self.msg_list.itemconfig(tk.END, fg='red')
                        self.msg_list.itemconfig(tk.END, bg='yellow')
                    elif v_color == 5:
                        self.msg_list.itemconfig(tk.END, fg='OrangeRed4')
                    elif v_color == 6:
                        self.msg_list.itemconfig(tk.END, fg='Purple1')
                self.msg_list.see("end")
                self.write_in_logfile(v_msg)
            elif v_type == 3:  # only in the log file
                self.write_in_logfile(v_msg)
        except:
            f_msg = "manage info"
            self.manage_error(
                " ".join(["Error in:", f_msg, "v_msg: ", v_msg, "v_type: ", str(v_type), "v_color: ", str(v_color)]),
                self.error_msg(sys.exc_info()), 1)
        # if debug then print the message
        if self.DEBUG:
            print(v_msg)
        try:
            self.msg_display.update()
        except:
            a = 0

    def manage_error(self, error_msg, error_info, info_type):
        """
        this function log each error in the file erreurs.txt
        """
        self.nbre_erreurs += 1
        v_msg = " ".join([datetime.now().strftime("%Y%m%d-%H%M%S"), "passe : ", str(self.nbre_passes),
                          self.in_file_name, error_msg, " "])
        with open("".join([self.log_path, "erreurs.txt"]), "a", encoding="utf-8") as fErr:
            fErr.write(": ".join([v_msg, error_info, "\n"]))

    def write_in_logfile(self, v_msg):
        """
        this function l....
        """
        log_file = ""
        if self.LOG_THIS_RUN:
            try:
                with open(self.log_path_file_name, "a", encoding="utf-8") as fLog:
                    fLog.write("".join([v_msg, "\n"]))
            except:
                f_msg = "function write_in_logfile : opening logfile"
                self.manage_error(" ".join(["Error in:", f_msg]), self.error_msg(sys.exc_info()), 1)

    def error_msg(self, error_info):
        """
        this function l....
        """
        # def error_msg(self, error_info):
        v_class = str(error_info[0]).replace("<class '", "").replace("'>", "")
        # v_class = str(error_info[0]).replace("<class '" or "'>", "")
        v_return = ": ".join([v_class, str(error_info[1])])
        return v_return

    def ask_2_quit(self):
        """
        this function l....
        """
        self.asked_2_quit = True
        self.msg_display.update_idletasks()

    def manage_buttons(self, from_who, in_out):
        """
        this function l....
        """

        if from_who == "btnFileJob" or from_who == "btnVerif" or from_who == "btnAddNav" or from_who == "btnXmlFormat":
            if in_out == "in":
                for obj in self.btn_frame.winfo_children():
                    obj.configure(state="disabled")
            if in_out == "out":
                for obj in self.btn_frame.winfo_children():
                    if str(obj.cget("textvariable")) != "btnStop":
                        obj.configure(state="normal")

        elif from_who == "btnDirJob" or from_who == "btnTest":
            if in_out == "in":
                for obj in self.btn_frame.winfo_children():
                    if str(obj.cget("textvariable")) != "btnStop":
                        obj.configure(state="disabled")
                    else:
                        obj.configure(state="normal")
            if in_out == "out":
                for obj in self.btn_frame.winfo_children():
                    if str(obj.cget("textvariable")) != "btnStop":
                        obj.configure(state="normal")
                    else:
                        obj.configure(state="disabled")

        # elif from_who == "btnBtnDirJob" or from_who == "btnTest":
        #     if in_out == "in":
        #         for obj in self.btn_frame.winfo_children():
        #             print(str(obj.cget("textvariable")))
        #             if str(obj.cget("textvariable")) != "btnStop":
        #                 obj.configure(state="disabled")
        #             else:
        #                 obj.configure(state="normal")
        #     if in_out == "out":
        #         for obj in self.btn_frame.winfo_children():
        #             if str(obj.cget("textvariable")) != "btnStop":
        #                 obj.configure(state="normal")
        #             else:
        #                 obj.configure(state="disabled")

    def generate_nav(self, text_path_dir, opf_dir, titles_levels):
        """
        this function l....
        """
        # print (titles_levels)
        # chapters_list = y.get_ebook_chapters_list (self.text_path_dir, self.ops_path_dir, titles_levels)
        chapters_list = []
        chapters_list = y.get_ebook_chapters_list(text_path_dir, opf_dir, titles_levels)
        nav_path_file_name = "".join([text_path_dir, "nav.xhtml"])
        # print (chapters_list)

        # chapter_max_deep = 0

        for t in chapters_list:
            # print(t)
            file_path_name = "".join([self.text_path_dir, t[0]])  # t[0] = file_name
            chapter_string = t[1]  # all the line
            chapter_id_nr = t[3]  # index value
            chapter_id = "".join(["FET_toc_id_", chapter_id_nr])

            xml_data_new = ""

            with open(file_path_name, "r", encoding="utf-8") as f:
                xml_txt = f.readlines()
                f.close()
            with open(file_path_name, "w", encoding="utf-8") as f:
                for line in xml_txt:
                    if chapter_string in line:
                        all_title_index = []
                        all_title_index = y.find_all_substr(line, "<h")
                        for h in all_title_index:
                            i_deb = h
                            i_end = line.find("</h", i_deb + 1)
                            str_2_analyse = line[i_deb: i_end]
                            if "id=" in str_2_analyse:
                                pos_id_tag = str_2_analyse.find("id=")
                                pos_id_val_beg = str_2_analyse.find("\"", pos_id_tag) + 1
                                pos_id_val_end = str_2_analyse.find("\"", pos_id_val_beg)
                                old_id = str_2_analyse[pos_id_val_beg: pos_id_val_end]
                                l_a = str_2_analyse.replace(old_id, chapter_id)
                                l_new = line.replace(str_2_analyse, l_a)
                            else:
                                c_beg = chapter_string[:3]
                                c_mid = "".join([" id=\"", chapter_id, "\""])
                                c_end = chapter_string[len(c_beg):]
                                c_new = "".join([c_beg, c_mid, c_end])
                                l_new = line.replace(chapter_string, c_new)
                        xml_data_new += l_new
                    else:
                        xml_data_new += line
                f.write(xml_data_new)

        # prepare the toc xml
        toc_beg = "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\" ?>\n" \
                    "<!DOCTYPE html>\n" \
                    "<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\">\n" \
                    "<head>\n" \
                    "	<title>Table des matieres</title>\n" \
                    "    <meta charset=\"utf-8\"/>\n" \
                    "</head>\n" \
                    "<body>\n" \
                    "    <nav epub:type=\"toc\" id=\"toc\">\n" \
                    "<h1>Table des matières</h1>\n"
        # toc_beg = "<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\" ?>\n" \
        #             "<!DOCTYPE html>\n" \
        #             "<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:epub=\"http://www.idpf.org/2007/ops\">\n" \
        #             "<head>\n" \
        #             "	<title>Table des matieres</title>\n" \
        #             "    <meta charset=\"utf-8\"/>\n" \
        #             "    <link href=\"../Styles/pw_table_style_v02_01.css\" rel=\"stylesheet\" type=\"text/css\"/>\n" \
        #             "    <link href=\"../Styles/fet_styles_v02_01.css\" rel=\"stylesheet\" type=\"text/css\"/>\n" \
        #             "</head>\n" \
        #             "<body>\n" \
        #             "    <nav epub:type=\"toc\" id=\"toc\">\n" \
        #             "<h1>Table des matières</h1>\n"
        toc_end = "</nav></body></html>"

        ol_open = '''<ol>\n'''
        ol_close = '''</ol>\n'''
        li_open = '''<li>\n'''
        li_close = '''</li>\n'''
        toc_mid = ol_open + li_open

        # create the toc
        working_chapter = 0
        while working_chapter < len(chapters_list):
            # print (len(chapters_list)-1)

            file_name = chapters_list[working_chapter][0].strip()
            chapter_string = chapters_list[working_chapter][1].strip()
            chapter_title = chapters_list[working_chapter][2].strip()
            chapter_id = chapters_list[working_chapter][3].strip()
            chapter_level = int(chapters_list[working_chapter][4].strip()[2:])
            chapter_number = chapter_title.split(" ")[0]

            # créer les entrée de la table nav.xhtml
            to_add = ""

            # for tt in chapters_list:
            #     print(tt)
            # print()

            if self.DEBUG:
                print(working_chapter, chapter_title)
            if working_chapter < len(chapters_list) - 1:
                next_level = int(chapters_list[working_chapter + 1][4].strip()[2:])
            else:
                next_level = 1

            if working_chapter > 0:
                act_level = int(chapters_list[working_chapter][4].strip()[2:])
            else:
                act_level = 1
                # to_add = ol_open + li_open

            delta_level = next_level - act_level

            dif_level = delta_level
            if delta_level > 0:
                while dif_level > 0:
                    to_add += ol_open + li_open
                    dif_level -= 1
            elif delta_level == 0:
                to_add += li_close + li_open
            elif delta_level < 0:
                while dif_level < 0:
                    to_add += li_close + ol_close
                    dif_level += 1
                to_add += li_close + li_open
                if delta_level > 0:
                    to_add += li_close + li_open

            # print(act_level, "/", next_level, "/",delta_level, "to_add : ",to_add.replace("\n", ""),  " --> ", chapter_title)

            # toc_mid += "".join([to_add, "<a class=\"fet_toc\" href=\"../Text/", str(file_name), "#FET_toc_id_", chapter_id, "\">", chapter_title, "</a>\n"])
            toc_mid += "".join(["<a class=\"fet_toc\" href=\"../Text/", str(file_name), "#FET_toc_id_", chapter_id, "\">", chapter_title, "</a>\n", to_add])

            working_chapter += 1
        toc_mid = toc_mid[:len(toc_mid)-6] + ol_close

        # toc_mid += li_close + ol_close

        with open(nav_path_file_name, "r", encoding="utf-8") as nav_file:
            xml_txt = nav_file.readlines()
            nav_file.close()

        with open(nav_path_file_name, "w", encoding="utf-8") as nav_file:

            toc_all = toc_beg
            toc_all += toc_mid
            toc_all += toc_end

            nav_file.write(toc_all)
            nav_file.close()

    def get_content_unique_id(self):

        txt_beg_id = "<dc:identifier id=\"pubId\">"
        txt_end_id = "</dc:identifier>"
        return_id = ""
        with open(self.content_path_file_name, "r", encoding="utf-8") as content_file:
            content_xml = content_file.readlines()
        for l in content_xml:
            if "<dc:identifier id=\"pubId\">" in l:
                index_beg_id = l.find(txt_beg_id)
                index_end_id = l.find(txt_end_id)
                return_id = l[index_beg_id + len(txt_beg_id):index_end_id]
                break
        return return_id

    def generate_toc(self, txt_dir, opf_dir, title_list):
        """
        this function l....
        """
        doc_title = self.out_file_name.split(".")[0]
        toc_beg = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" \
                    "<ncx xmlns=\"http://www.daisy.org/z3986/2005/ncx/\" version=\"2005-1\">\n" \
                    "  <head>\n" \
                    "    <meta name=\"dtb:uid\" content=\"unique_id_2_replace\"/>\n" \
                    "    <meta name=\"dtb:depth\" content=\"2\" />\n" \
                    "    <meta name=\"dtb:totalPageCount\" content=\"0\" />\n" \
                    "    <meta name=\"dtb:maxPageNumber\" content=\"0\" />\n" \
                    "  </head>\n" \
                    "<docTitle>\n" \
                    "  <text>the_title_2_replace</text>\n" \
                    "</docTitle>\n" \
                    "<navMap>\n"
        toc_beg = toc_beg.replace("the_title_2_replace", doc_title)
        content_id = self.get_content_unique_id()

        toc_beg = toc_beg.replace("unique_id_2_replace", content_id) # str(uuid.uuid4()))
        toc_mid = ""
        toc_end = "</navMap></ncx>"

        chapters_list = y.get_ebook_chapters_list(txt_dir, opf_dir, title_list)

        nav_id = 1
        for ch in chapters_list:
            file_name = ch[0].strip()
            chapter_string = ch[1].strip()
            chapter_title = ch[2].strip()
            chapter_id = ch[3].strip()
            chapter_level = int(ch[4].strip()[2:])
            chapter_number = chapter_title.split(" ")[0]
            if chapter_number[0].isnumeric():
                k = 0
                chapter_title_new = ""
                for t in chapter_title.split(" "):
                    if k > 0:
                        chapter_title_new = " ".join([chapter_title_new, t])
                    k += 1
                chapter_title = "".join([chapter_title_new, " (", chapter_number, ")"])
            nav_id_str = "{:02d}".format(nav_id)
            toc_mid += "".join(["<navPoint id=\"navPoint", nav_id_str, "\">\n"])
            toc_mid += "<navLabel>\n"
            toc_mid += "".join(["<text> ", chapter_title, "</text>\n"])
            toc_mid += "</navLabel>\n"
            toc_mid += "".join(["<content src=\"Text/", str(file_name), "#FET_toc_id_", chapter_id, "\"/>\n"])
            toc_mid += "</navPoint>\n"

            nav_id += 1

        toc_all = toc_beg
        toc_all += toc_mid
        toc_all += toc_end

        ncx_path_file_name = "".join([opf_dir, "toc.ncx"])
        with open(ncx_path_file_name, "w", encoding="utf-8") as ncx_file:
            ncx_file.write(toc_all)
            ncx_file.close()

    def delete_line_with_PW_add_cont_in_opf(self, opf_file_path_name):

        n_changes = 0
        # read the content of .opf file in xml_opf_lines[]
        with open(opf_file_path_name, "r", encoding="utf-8") as opf_file:
            xml_opf_lines = [x.strip() for x in opf_file.readlines()]
            opf_file.close()

        new_xml_opf_lines = []
        # pour chaque ligne du fichier content.opf
        for opf_line in xml_opf_lines:
            if "PW_add_cont" not in opf_line:
                new_xml_opf_lines.append(opf_line)
            else:
                n_changes += 1

        with open(opf_file_path_name, "w", encoding="utf-8") as opf_file:
            for item in new_xml_opf_lines:
                opf_file.write("{}\n".format(item))
            opf_file.close()

        return "", n_changes

    def replace_asolute_with_relative_in_exercices_css(self, style_path_name):

        n_changes = 0
        css_exo_path_file_name = "".join([self.style_path_name, "exercises.css"])
        if os.path.exists(css_exo_path_file_name):

            # read the content of .opf file in xml_opf_lines[]
            with open(css_exo_path_file_name, "r", encoding="utf-8") as css_file:
                css_lines = [x.strip() for x in css_file.readlines()]
                css_file.close()

            new_css_lines = []
            # pour chaque ligne du fichier content.opf
            for opf_line in css_lines:
                if "absolute" not in opf_line:
                    new_css_lines.append(opf_line)
                else:
                    new_css_lines.append(opf_line.replace("absolute", "relative"))
                    n_changes += 1

            with open(css_exo_path_file_name, "w", encoding="utf-8") as css_file:
                for item in new_css_lines:
                    css_file.write("{}\n".format(item))
                css_file.close()

        return "", n_changes

    def delete_exercises0001_css_and_update_content_opf(self, style_path_name, opf_file_path_name):

        # delete exercices0001.css witch is not used
        css_exo_0001_path_file_name = "".join([style_path_name, "exercises0001.css"])
        if os.path.exists(css_exo_0001_path_file_name):
            os.remove(css_exo_0001_path_file_name)

        n_changes = 1
        # read the content of .opf file in xml_opf_lines[]
        with open(opf_file_path_name, "r", encoding="utf-8") as opf_file:
            xml_opf_lines = [x.strip() for x in opf_file.readlines()]
            opf_file.close()

        new_xml_opf_lines = []
        # pour chaque ligne du fichier content.opf
        for opf_line in xml_opf_lines:
            if "exercises0001.css" not in opf_line:
                new_xml_opf_lines.append(opf_line)
            else:
                n_changes += 1

        with open(opf_file_path_name, "w", encoding="utf-8") as opf_file:
            for item in new_xml_opf_lines:
                opf_file.write("{}\n".format(item))
            opf_file.close()

        return "", n_changes

    # procédure de vérification des epubs par le jar de W3C
    def w3c_epub_check (self, in_file_name, out_file_name):

        epub_check_dir = "".join([self.cwd, "epubcheck/"])
        epub_check_file = "epubcheck.jar"
        java_epub_check_path_file_name = "".join([epub_check_dir, epub_check_file])

        # execution de l'application java
        all_args = ['java', "-jar", java_epub_check_path_file_name, in_file_name, "-o", out_file_name, "-q", "--w"]
        subprocess.call(all_args)
        # parcourir le fichier xml de sortie
        with open("".join([self.log_path, "epub_verif.xml"]), "r", encoding="utf-8") as verif_file:
            result_xml_data = verif_file.readlines()

        n_err = 0
        n_fatal = 0
        n_error = 0
        n_warn = 0
        f_ok = False
        ret_msg = []

        # inscrire les résultats en clair dans le fichier txt de sortie
        YY = str(datetime.now().year)
        MM = str(datetime.now().month)
        DD = str(datetime.now().day)
        hh = str(datetime.now().hour)
        mm = str(datetime.now().minute)
        ss = str(datetime.now().second)
        compete_date_time = "".join([DD, ".", MM, ".", YY, " ", hh,":",mm,":", ss, "\n"])
        ret_msg.append(compete_date_time)

        ret_msg.append("".join([in_file_name, "\n"]))

        for l in result_xml_data:
            # print (l)
            if "Well-formed" in l:
                f_ok = True
            if "<message severity=" in l:
                n_err += 1
                if "FATAL" in l:
                    n_fatal += 1
                if "ERROR" in l:
                    n_error += 1
                if "WARN" in l:
                    n_warn += 1
                sm = l.find("\">") + 2
                em = l.find("</message>")
                ret_msg.append("".join([str(n_err), " : ", l[sm:em], "\n"]))
        ret_msg.append("".join(["Check status : ",str(n_fatal), " fatal / ", str(n_error), " errors / ", str(n_warn), " warnings\n"]))
        return f_ok, n_err, n_fatal, n_error, n_warn, ret_msg

